<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Armonía de las Esferas</title>
    <!-- Carga de Tailwind CSS para estilos modernos y responsivos -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configuración de Tailwind para incluir colores personalizados
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'space-dark': '#0d0d1a',
                        'space-blue': '#1a202c',
                        // Se define el naranja de la marca para usar en hover/focus
                        'brand-orange': '#f75b0f', 
                    }
                }
            }
        }
    </script>
    <!-- Carga de Three.js para la renderización 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Carga de Tone.js para la generación de audio -->
    <script src="https://unpkg.com/tone@14.7.58/build/Tone.js"></script>
    <style>
        /* Estilos personalizados para el cuerpo y el canvas */
        body {
            margin: 0;
            overflow: hidden; /* Evita barras de desplazamiento */
            font-family: 'Inter', sans-serif;
            background-color: #0d0d1a; /* Fondo oscuro espacial */
        }
        canvas {
            display: block;
            touch-action: none; /* Previene el comportamiento nativo del navegador al arrastrar */
        }
        /* Intenta aumentar el grosor de línea si el navegador lo permite */
        canvas.webgl-canvas {
            stroke-width: 2px;
        }
    </style>
</head>
<body>

    <!-- Contenedor del Canvas y Overlay de Instrucciones -->
    <div id="container"></div>

    <!-- Overlay de Inicio - AHORA CUBRE TODA TODA LA PANTALLA CON EL COLOR NARANJA -->
    <div id="overlay" style="background-color: #f75b0f;" class="fixed inset-0 flex flex-col items-center justify-center p-4 text-white transition-opacity duration-500 ease-in-out z-10">
        
        <div class="flex flex-col items-center text-center p-4">
            
            <!-- Título principal en color blanco, más grande y prominente -->
            <h1 class="text-6xl sm:text-7xl font-extrabold mb-12 text-white uppercase tracking-wider">
                Armonía de las Esferas
            </h1>
            
            <!-- Botón de inicio en blanco con texto naranja, más grande -->
            <button id="startButton" class="px-10 py-5 bg-white hover:bg-gray-200 text-brand-orange font-extrabold text-xl rounded-xl shadow-2xl transition transform hover:scale-105">
                ¡Empezar Simulación!
            </button>
        </div>
    </div>
    
    <!-- Controles Flotantes -->
    <div id="controls" class="fixed inset-x-0 bottom-4 flex flex-col items-center space-y-3 z-20 opacity-0 transition-opacity duration-500 pointer-events-none sm:flex-row sm:justify-between sm:bottom-auto sm:top-4 sm:space-y-0 sm:px-6">
        
        <!-- Botón Pausar/Reanudar -->
        <div class="sm:order-1 sm:w-auto">
            <button id="pauseButton" class="px-5 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50">
                Pausar Simulación
            </button>
        </div>

        <!-- Menú de Selección de Entidad -->
        <div class="w-full sm:w-auto sm:order-2">
            <label for="entitySelect" class="block text-sm font-medium text-white mb-1">Crear:</label>
            <select id="entitySelect" class="w-full sm:w-36 p-2 bg-gray-800 text-white rounded-lg border border-gray-700 focus:ring-brand-orange focus:border-brand-orange transition duration-150">
                <option value="planet">Planeta</option>
                <option value="sun">Sol</option>
            </select>
        </div>

        <!-- Botón Reiniciar Simulación (Bottom-Center) -->
        <div class="sm:order-4 sm:w-auto">
            <button id="clearButton" style="background-color: #f75b0f;" class="px-5 py-3 hover:bg-orange-700 text-white font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-orange-500 focus:ring-opacity-50">
                Reiniciar Simulación
            </button>
        </div>
    </div>

    <script>
        // Configuración global de Three.js
        let scene, camera, renderer;
        let ambientLight;
        let starField; // Variable para el campo de estrellas
        
        // --- ARRAYS GLOBALES PARA MÚLTIPLES OBJETOS ---
        const suns = []; 
        const planets = [];
        
        // =================================================================
        // CONSTANTES DE FÍSICA Y TIEMPO
        // =================================================================
        const GRAVITATIONAL_CONSTANT = 1.0; 
        const SUN_MASS = 1000.0; 
        const PLANET_MASS = 1.0; 
        const TIME_STEP = 0.05; 
        const MIN_DISTANCE = 25;
        const MAX_DISTANCE = 150;
        const COLLISION_DISTANCE = 18; 
        const MAX_SUN_DISTANCE = 100; 
        
        // Aumentamos la longitud del rastro a 100 puntos (antes 50)
        const TRAIL_LENGTH = 100; 
        
        // NUEVA VARIABLE DE ESTADO
        let isPaused = false;
        
        // Objeto para ayudar en la conversión de coordenadas 2D a 3D
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        
        // Vectores temporales para evitar reasignaciones constantes y ahorrar memoria/rendimiento
        const tempVector = new THREE.Vector3();
        
        // =================================================================
        // VARIABLES DE CONTROL DE CÁMARA (MANUAL)
        // =================================================================
        let isDragging = false; 
        let isPointerActive = false;
        let pointerStart = { x: 0, y: 0 };
        let previousPointerPosition = { x: 0, y: 0 };
        const ORBIT_RADIUS = 150; 
        
        let theta = 0; 
        let phi = Math.PI / 2;
        
        const DAMPING_FACTOR = 0.9; 
        const ROTATION_MULTIPLIER = 0.005;
        let velocityX = 0;
        let velocityY = 0;
        
        const DRAG_THRESHOLD = 5;

        // =================================================================
        // CONFIGURACIÓN DE AUDIO (TONE.JS)
        // =================================================================
        let isAudioContextStarted = false;
        // Escala musical BAJADA UNA OCTAVA para tonos más graves y suaves.
        const NOTE_SCALE = ['C2', 'D2', 'E2', 'G2', 'A2', 'C3', 'D3', 'E3']; 
        
        const TRIGGER_ANGLE_DEG = 20; // Arco de 20 grados donde se activa el sonido
        const TRIGGER_ANGLE_RAD = THREE.MathUtils.degToRad(TRIGGER_ANGLE_DEG);
        // Duración más larga para el efecto de sostenido
        const NOTE_DURATION = '4n'; 

        // Se inicializa una reverberación para dar un ambiente espacial a todos los sonidos
        const reverb = new Tone.Reverb({
            decay: 2.5,
            preDelay: 0.02,
            wet: 0.3 
        }).toDestination();


        /**
         * Crea el sintetizador único con un sonido de cuerda sostenido.
         * Se simplifica la lógica ya que eliminamos los tipos de instrumento.
         * @returns {object} Un objeto con la instancia del sintetizador.
         */
        function createSynth() {
            // Configuración para un sonido de onda sinusoidal (sine)
            const config = {
                oscillator: { type: "sine" }, // Onda Sinusoidal
                envelope: { 
                    attack: 0.05, 
                    decay: 0.5, 
                    sustain: 0.0, 
                    release: 1.5 // El release largo es lo que da el "sostenido"
                },
                volume: -10 // Volumen ligeramente más bajo para la reverberación
            };
            
            const synthInstance = new Tone.Synth(config).connect(reverb);
            return { synth: synthInstance, type: 'Synth' };
        }


        /**
         * Inicializa el AudioContext de Tone.js después del primer toque del usuario.
         */
        function startAudioContext() {
            if (!isAudioContextStarted) {
                Tone.start(); 
                isAudioContextStarted = true;
            }
        }

        // =================================================================
        // FUNCIONES DE FÍSICA
        // =================================================================

        /**
         * Calcula la aceleración gravitacional neta sobre el planeta causada por todos los soles.
         * F = G * M1 * M2 / r^2
         * A = F / M2 = G * M1 / r^2
         * @param {object} planet El objeto planeta con posición, masa y aceleración.
         */
        function calculateGravity(planet) {
            const netAcceleration = new THREE.Vector3(0, 0, 0);

            suns.forEach(sun => {
                // Vector que apunta del planeta al sol
                // Usamos sun.mesh.position porque es la instancia THREE.Vector3 del mesh.
                const direction = tempVector.copy(sun.mesh.position).sub(planet.mesh.position);
                const distanceSq = direction.lengthSq();

                // Evitar división por cero o fuerzas infinitas en colisión cercana
                if (distanceSq < 1) { 
                    return;
                }
                
                const distance = Math.sqrt(distanceSq);

                // Fuerza gravitacional: A = (G * M_sol / r^2) * (vector unitario)
                const magnitude = (GRAVITATIONAL_CONSTANT * SUN_MASS) / distanceSq;

                // Asegurar que la fuerza no sea demasiado grande a corta distancia
                const maxMagnitude = 5.0; // Límite de aceleración para estabilidad
                const finalMagnitude = Math.min(magnitude, maxMagnitude);

                direction.normalize().multiplyScalar(finalMagnitude);
                
                netAcceleration.add(direction);
            });

            planet.acceleration = netAcceleration;
        }

        /**
         * Aplica la integración de Euler para actualizar la velocidad y posición.
         * @param {object} planet El objeto planeta.
         * @param {number} deltaTime El paso de tiempo.
         */
        function updatePhysics(planet, deltaTime) {
            // Velocidad = Velocidad + Aceleración * dt
            planet.velocity.add(planet.acceleration.clone().multiplyScalar(deltaTime));
            
            // Posición = Posición + Velocidad * dt
            planet.mesh.position.add(planet.velocity.clone().multiplyScalar(deltaTime));
        }

        /**
         * Encuentra el Sol más cercano al punto de click.
         * @param {THREE.Vector3} clickPosition Posición 3D del click.
         * @returns {object} El objeto Sol más cercano.
         */
        function findNearestSun(clickPosition) {
            let minDistanceSq = Infinity;
            let nearestSun = null;
            
            suns.forEach(sun => {
                // Usamos subVectors y lengthSq para calcular la distancia.
                const diffVector = new THREE.Vector3().subVectors(sun.mesh.position, clickPosition);
                const distanceSq = diffVector.lengthSq(); 
                
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    nearestSun = sun;
                }
            });

            return nearestSun;
        }

        // =================================================================
        // UTILIDADES
        // =================================================================

        /**
         * Inicializa la escena, cámara, renderizador y luces.
         */
        function init() {
            // 1. Configuración de la Escena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0d0d1a, 0.003); 

            // 2. Configuración de la Cámara (perspectiva para 3D)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, ORBIT_RADIUS); // Posición inicial
            
            // 3. Configuración del Renderizador (WebGL)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
            // Añadir una clase para apuntar con CSS si queremos aumentar el grosor de línea
            renderer.domElement.classList.add('webgl-canvas'); 
            document.getElementById('container').appendChild(renderer.domElement);
            
            // 4. Configuración de la Iluminación
            ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
            scene.add(ambientLight);

            // 5. Crear el Sol Central Inicial y el Fondo de Estrellas
            createInitialSun(); 
            createStarField(); 
            
            // 6. Manejadores de Eventos
            window.addEventListener('resize', onWindowResize, false);
            setupPointerControls(renderer.domElement);
            document.getElementById('pauseButton').addEventListener('click', togglePause);
        }

        /**
         * Crea el primer Sol al iniciar la simulación.
         */
        function createInitialSun() {
            const center = new THREE.Vector3(0, 0, 0);
            createSunAtPosition(center);
        }

        /**
         * Crea un objeto Sol y lo añade a la escena y al array de Soles.
         * @param {THREE.Vector3} position Posición del nuevo sol.
         */
        function createSunAtPosition(position) {
            const sunRadius = 12;
            const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32); 
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                emissive: 0xff8800 
            }); 
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.copy(position);
            scene.add(sunMesh);
            
            const flareTexture = generateRadialTexture(); 

            const lightSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: flareTexture,
                color: 0xff8800, 
                blending: THREE.AdditiveBlending, 
                transparent: true,
                opacity: 0.7 
            }));
            lightSprite.scale.set(50, 50, 1.0); 
            sunMesh.add(lightSprite);

            // Cada sol necesita una luz para iluminar a los planetas a su alrededor
            const sunLight = new THREE.PointLight(0xffffff, 3.0, 0, 0); 
            sunLight.position.copy(position);
            scene.add(sunLight);

            // Se almacena el mesh para acceder a su posición Vector3
            suns.push({ mesh: sunMesh, light: sunLight, mass: SUN_MASS });
        }


        /**
         * Crea un campo de estrellas aleatorias para el fondo.
         */
        function createStarField() {
            const starCount = 1500;
            const starGeometry = new THREE.BufferGeometry();
            const positions = [];
            
            const radius = 500; 

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(radius * 2);
                const y = THREE.MathUtils.randFloatSpread(radius * 2);
                const z = THREE.MathUtils.randFloatSpread(radius * 2);

                positions.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1, 
                sizeAttenuation: true 
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }
        
        /**
         * Genera una textura circular suave con degradado para simular un brillo (flare).
         */
        function generateRadialTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');

            const gradient = context.createRadialGradient(
                size / 2, size / 2, 0, 
                size / 2, size / 2, size / 2 
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)'); 
            gradient.addColorStop(1, 'rgba(255,255,255,0)'); 

            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);

            return new THREE.CanvasTexture(canvas);
        }

        /**
         * Configura los eventos de mouse y touch para el control de la cámara.
         */
        function setupPointerControls(element) {
            element.addEventListener('pointerdown', onPointerDown, false);
            element.addEventListener('pointermove', onPointerMove, false);
            element.addEventListener('pointerup', onPointerUp, false);
            element.addEventListener('pointerleave', onPointerUp, false);
        }

        /**
         * Evento al pulsar (clic o tocar).
         */
        function onPointerDown(event) {
            if (event.buttons === 1 || event.pointerType === 'touch') { 
                isPointerActive = true; 
                isDragging = false; 
                
                pointerStart.x = event.clientX;
                pointerStart.y = event.clientY;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
                velocityX = 0;
                velocityY = 0;
            }
        }

        /**
         * Evento al mover el puntero (arrastrar).
         */
        function onPointerMove(event) {
            
            if (!isPointerActive) return; 

            if (!isDragging) {
                const deltaMovementX = event.clientX - pointerStart.x;
                const deltaMovementY = event.clientY - pointerStart.y;
                const distance = Math.sqrt(deltaMovementX * deltaMovementX + deltaMovementY * deltaMovementY); 
                
                if (distance > DRAG_THRESHOLD) {
                    isDragging = true; 
                }
            }

            if (isDragging) { 
                const deltaX = event.clientX - previousPointerPosition.x;
                const deltaY = event.clientY - previousPointerPosition.y;

                theta += deltaX * ROTATION_MULTIPLIER;
                phi -= deltaY * ROTATION_MULTIPLIER;
                
                velocityX = deltaX * ROTATION_MULTIPLIER * 0.5;
                velocityY = deltaY * ROTATION_MULTIPLIER * 0.5;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
            }
        }

        /**
         * Evento al soltar (dejar de arrastrar o crear entidad).
         */
        function onPointerUp(event) {
            if (isPointerActive && !isDragging) { 
                const entitySelect = document.getElementById('entitySelect');
                const selectedEntity = entitySelect ? entitySelect.value : 'planet';
                
                if (selectedEntity === 'planet') {
                    createPlanet(event);
                } else if (selectedEntity === 'sun') {
                    createSunOnClick(event);
                }
            }
            
            isDragging = false; 
            isPointerActive = false; 
        }

        /**
         * Intenta crear un Sol en la posición del click/toque.
         */
        function createSunOnClick(event) {
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);

            // Limitar la distancia del Sol para evitar que aparezca muy lejos
            if (intersection.length() > MAX_SUN_DISTANCE) {
                intersection.normalize().multiplyScalar(MAX_SUN_DISTANCE);
                showMessage('Sol colocado en el límite de la zona central.', 2000, new THREE.Color(0xfacc15));
            }


            createSunAtPosition(intersection);
            showMessage('¡Nuevo Sol Creado! Ahora afecta la gravedad.', 2000, new THREE.Color(0xfacc15));
        }

        /**
         * Crea un nuevo planeta.
         * @param {PointerEvent} event El evento de puntero (contiene clientX/Y).
         */
        function createPlanet(event) {
            startAudioContext(); 

            if (suns.length === 0) {
                showMessage('No hay soles para orbitar. ¡Crea un Sol primero!', 3000, new THREE.Color(0xef4444));
                return;
            }

            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);
            const initialPosition = intersection.clone();

            // --- 1. ENCONTRAR EL SOL MÁS CERCANO PARA INICIALIZAR LA ÓRBITA ---
            const nearestSun = findNearestSun(initialPosition);
            
            // Usamos la posición del mesh del sol para la física
            const relativePosition = initialPosition.clone().sub(nearestSun.mesh.position);
            const distance = relativePosition.length();

            if (distance < COLLISION_DISTANCE) {
                showMessage('Demasiado cerca del Sol. Intenta más lejos.', 3000, new THREE.Color(0xfacc15));
                return;
            }

            // 2. CÁLCULO DE VELOCIDAD INICIAL (para órbita circular aproximada alrededor del Sol más cercano)
            
            // Magnitud de la velocidad orbital: v = sqrt(G*M/r)
            const orbitVelocityMag = Math.sqrt((GRAVITATIONAL_CONSTANT * SUN_MASS) / distance);
            
            // Dirección de la velocidad: perpendicular al vector posición (para iniciar la órbita)
            const positionUnit = relativePosition.clone().normalize();
            
            // Usa el producto cruz con el vector 'up' (Y=1) para obtener una velocidad tangencial
            let initialVelocity = new THREE.Vector3().crossVectors(positionUnit, new THREE.Vector3(0, 1, 0));
            
            // Si el producto cruz es casi cero (el planeta está en Y, que no debería pasar aquí)
            if (initialVelocity.lengthSq() < 0.001) {
                initialVelocity.set(1, 0, 0); 
            }
            
            // Velocidad inicial más ajustada (0.95 a 1.05) para asegurar una órbita estable
            initialVelocity.normalize().multiplyScalar(orbitVelocityMag * THREE.MathUtils.randFloat(0.95, 1.05));

            // Añadir una pequeña componente Y para dar una inclinación 3D inicial
            initialVelocity.y = THREE.MathUtils.randFloatSpread(orbitVelocityMag * 0.1); 

            // 3. GENERAR EL RESTO DE PROPIEDADES
            const radius = THREE.MathUtils.randFloat(1, 4); 
            
            const baseColor = new THREE.Color(Math.random(), Math.random(), Math.random());
            const hsl = {};
            baseColor.getHSL(hsl);
            hsl.l = THREE.MathUtils.randFloat(0.7, 0.9);
            hsl.s = THREE.MathUtils.randFloat(0.4, 0.8); 
            const brightColor = new THREE.Color().setHSL(hsl.h, hsl.s, hsl.l);


            // 4. Configuración de AUDIO
            const { synth } = createSynth(); // Usa la función simplificada
            
            // Lógica de nota basada en distancia (misma que antes)
            const distanceRange = MAX_DISTANCE - MIN_DISTANCE;
            const distanceRatio = (distance - MIN_DISTANCE) / distanceRange;
            // Asegura que el índice de nota esté ligado a la escala más baja (C2 a E3)
            const noteIndex = Math.floor((1.0 - distanceRatio) * NOTE_SCALE.length); 
            const clampedIndex = Math.min(NOTE_SCALE.length - 1, Math.max(0, noteIndex));
            const planetNote = NOTE_SCALE[clampedIndex];

            // Ajuste de tono basado en velocidad (detune)
            const minV = 0.05; 
            const maxV = 0.5;
            const speedRatio = (initialVelocity.length() - minV) / (maxV - minV);
            const detuneRange = 200; 
            const detune = THREE.MathUtils.mapLinear(speedRatio, 0, 1, -detuneRange / 2, detuneRange / 2); 
            synth.set({ detune: detune });


            // 5. Malla y Rastro (similar al código anterior)
            const planetGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const planetMaterial = new THREE.MeshLambertMaterial({ 
                color: brightColor, 
                emissive: brightColor.clone().multiplyScalar(0.1) 
            });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
            planetMesh.position.copy(initialPosition);

            const orbitPositions = new Float32Array(TRAIL_LENGTH * 3); 
            const drawingPositions = new Float32Array(TRAIL_LENGTH * 3);
            
            // Creación del Array de Colores (RGBA: 4 componentes por punto)
            const trailColors = new Float32Array(TRAIL_LENGTH * 4); 

            const trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(drawingPositions, 3)); 
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 4)); // Añadir atributo de color/opacidad
            
            const trailMaterial = new THREE.LineBasicMaterial({
                color: brightColor, 
                transparent: true,
                opacity: 1.0,
                vertexColors: true // Usar colores definidos por el vértice
            });
            const orbitTrail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(orbitTrail);

            // 6. Crear Objeto para el planeta (PROPIEDADES DE FÍSICA Y AUDIO)
            const planetObject = {
                mesh: planetMesh,
                trail: orbitTrail,
                orbitPositions: orbitPositions, 
                trailColors: trailColors, // Almacenar el array de colores
                planetColor: brightColor, // Color base del planeta
                trailIndex: 0,
                trailLength: TRAIL_LENGTH,
                trailCount: 0,
                // PROPIEDADES DE FÍSICA
                mass: PLANET_MASS,
                velocity: initialVelocity, // Vector3
                acceleration: new THREE.Vector3(0, 0, 0), // Vector3
                // PROPIEDADES DE AUDIO
                synth: synth,
                note: planetNote,
                hasTriggered: false, 
            };

            scene.add(planetMesh);
            planets.push(planetObject);
            
            showMessage(`¡Planeta Creado con Gravedad Multi-Estrella!`, 1500, brightColor);
        }

        /**
         * Alterna el estado de pausa de la simulación y la música.
         */
        function togglePause() {
            isPaused = !isPaused;
            const button = document.getElementById('pauseButton');
            
            if (isPaused) {
                button.textContent = 'Reanudar Simulación';
                button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                button.classList.add('bg-green-600', 'hover:bg-green-700');
                Tone.Master.mute = true;
                showMessage('Simulación PAUSADA.', 1500, new THREE.Color(0xfb923c));
            } else {
                button.textContent = 'Pausar Simulación';
                button.classList.remove('bg-green-600', 'hover:bg-green-700');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700');
                Tone.Master.mute = false;
                showMessage('Simulación REANUDADA.', 1500, new THREE.Color(0x22c55e));
            }
        }

        /**
         * Elimina todos los planetas, soles, sus rastros y sus sintetizadores.
         */
        function clearSimulation() {
            const initialSuns = suns.length;
            const initialPlanets = planets.length;
            
            if (isPaused) {
                togglePause(); // Asegura reanudar si estaba pausado
            }

            // Limpieza de Planetas
            planets.forEach(planet => {
                if (planet.synth) planet.synth.dispose();
                scene.remove(planet.mesh);
                scene.remove(planet.trail);
            });
            planets.length = 0;

            // Limpieza de Soles
            suns.forEach(sun => {
                scene.remove(sun.mesh);
                scene.remove(sun.light);
            });
            suns.length = 0;
            
            // Vuelve a crear el sol inicial
            if (initialSuns === 0) {
                 createInitialSun(); 
            }

            showMessage('Simulación Reiniciada. ¡Crea nuevos sistemas!', 2500, new THREE.Color(0xef4444));
        }

        /**
         * Maneja el redimensionamiento de la ventana para mantener la vista correcta.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * Bucle principal de animación (game loop).
         */
        function animate() {
            requestAnimationFrame(animate);
            
            // 0. Rotación sutil del campo de estrellas
            if (starField) {
                starField.rotation.y += 0.00005; 
            }

            // 1. Mover Planetas y Actualizar Rastros y Audio (SOLO si NO está pausado)
            if (!isPaused) {
                for (let i = planets.length - 1; i >= 0; i--) {
                    const planet = planets[i];

                    // a. Calcular fuerzas y actualizar física
                    calculateGravity(planet);
                    updatePhysics(planet, TIME_STEP);
                    
                    // b. Detección de colisión (Ya no elimina) / expulsión (SOLO ELIMINA POR EXPULSIÓN)
                    if (planet.mesh.position.length() > 300) {
                        // Expulsión: Eliminar planeta
                        if (planet.synth) planet.synth.dispose();
                        scene.remove(planet.mesh);
                        scene.remove(planet.trail);
                        planets.splice(i, 1);
                        showMessage('¡Planeta Escapado! Limpiado.', 1000, new THREE.Color(0xff4444));
                        continue; // Pasa al siguiente planeta
                    }


                    // c. LÓGICA DE AUDIO
                    
                    // 1. Encontrar el sol más cercano para establecer la base de la órbita actual
                    const nearestSun = findNearestSun(planet.mesh.position);
                    
                    if (nearestSun) {
                        // 2. Calcular la posición del planeta relativa al Sol más cercano
                        const relativePosition = tempVector.copy(planet.mesh.position).sub(nearestSun.mesh.position);
                        
                        // 3. Calcular el ángulo relativo en el plano XZ (horizontal)
                        const relativeAngle = Math.atan2(relativePosition.z, relativePosition.x);
                        let normalizedAngle = relativeAngle % (Math.PI * 2);
                        if (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
                        
                        const triggerStart = (2 * Math.PI) - (TRIGGER_ANGLE_RAD / 2); 
                        const triggerEnd = TRIGGER_ANGLE_RAD / 2;
                        
                        const isInTriggerZone = normalizedAngle >= triggerStart || normalizedAngle <= triggerEnd;

                        if (isInTriggerZone && !planet.hasTriggered) {
                            planet.synth.triggerAttackRelease(planet.note, NOTE_DURATION);
                            planet.hasTriggered = true;
                            planet.mesh.material.emissiveIntensity = 2.0; 
                        } else if (!isInTriggerZone) {
                            planet.hasTriggered = false;
                            planet.mesh.material.emissiveIntensity = 0.1;
                        }
                    }

                    // d. Rotación propia del planeta
                    planet.mesh.rotation.y += 0.01;

                    // e. Actualizar rastro de órbita y colores (opacidad)
                    const orbitPositions = planet.orbitPositions;
                    const positionsAttribute = planet.trail.geometry.attributes.position;
                    const colorsAttribute = planet.trail.geometry.attributes.color;
                    const positionsForDrawing = positionsAttribute.array;
                    const colorsForDrawing = colorsAttribute.array;
                    
                    const index = planet.trailIndex * 3;

                    // 1. Guardar nueva posición
                    orbitPositions[index] = planet.mesh.position.x;
                    orbitPositions[index + 1] = planet.mesh.position.y;
                    orbitPositions[index + 2] = planet.mesh.position.z;

                    planet.trailIndex = (planet.trailIndex + 1) % planet.trailLength;
                    
                    if (planet.trailCount < planet.trailLength) {
                        planet.trailCount++;
                    }

                    // 2. Reordenar puntos y aplicar colores/opacidad
                    let p_index = 0; 
                    const totalPoints = planet.trailCount < planet.trailLength ? planet.trailCount : planet.trailLength;
                    const baseColor = planet.planetColor;

                    const updatePoint = (j, opacityRatio) => {
                        // Posición
                        positionsForDrawing[p_index * 3] = orbitPositions[j * 3];
                        positionsForDrawing[p_index * 3 + 1] = orbitPositions[j * 3 + 1];
                        positionsForDrawing[p_index * 3 + 2] = orbitPositions[j * 3 + 2];
                        
                        // Color y Opacidad (RGBA)
                        colorsForDrawing[p_index * 4] = baseColor.r;
                        colorsForDrawing[p_index * 4 + 1] = baseColor.g;
                        colorsForDrawing[p_index * 4 + 2] = baseColor.b;
                        colorsForDrawing[p_index * 4 + 3] = opacityRatio; // Opacidad

                        p_index++;
                    };
                    
                    const calculateOpacity = (i) => {
                        // i: índice absoluto del punto, de 0 al totalPoints-1
                        // Opacidad va de 0.0 al inicio del rastro a 1.0 al final (cerca del planeta)
                        // Para que el rastro sea más grueso al inicio (y no un desvanecimiento tan rápido), 
                        // cambiamos la curva de opacidad para que empiece más alto.
                        
                        // Opacidad lineal: return i / totalPoints;
                        // Opacidad con más cuerpo al inicio (ej. empieza en 0.2, sube a 1.0):
                        const minOpacity = 0.2;
                        const factor = 1.0 - minOpacity;
                        return minOpacity + (i / totalPoints) * factor; 
                    };


                    if (planet.trailCount < planet.trailLength) {
                        // FASE DE LLENADO: Rastro desde el punto 0 hasta el punto actual
                        for (let j = 0; j < planet.trailCount; j++) {
                            const opacityRatio = calculateOpacity(j);
                            updatePoint(j, opacityRatio);
                        }
                        planet.trail.geometry.setDrawRange(0, planet.trailCount);

                    } else {
                        // FASE ESTABLE: Rastro completo (buffer circular)
                        let opacityCounter = 0;
                        
                        // Parte A: Desde el punto actual (el más viejo) hasta el final del array
                        for (let j = planet.trailIndex; j < planet.trailLength; j++) {
                            const opacityRatio = calculateOpacity(opacityCounter++);
                            updatePoint(j, opacityRatio);
                        }
                        // Parte B: Desde el inicio del array (punto 0) hasta el punto actual (el más reciente)
                        for (let j = 0; j < planet.trailIndex; j++) {
                            const opacityRatio = calculateOpacity(opacityCounter++);
                            updatePoint(j, opacityRatio);
                        }
                        
                        planet.trail.geometry.setDrawRange(0, planet.trailLength);
                    }

                    positionsAttribute.needsUpdate = true;
                    colorsAttribute.needsUpdate = true; // Notificar a Three.js que los colores cambiaron
                }
            }
            
            // 2. Mover la Cámara (Controles Manuales e Inercia) - Esto siempre debe funcionar
            if (!isDragging) {
                theta += velocityX;
                phi -= velocityY; 
                velocityX *= DAMPING_FACTOR;
                velocityY *= DAMPING_FACTOR;
            }

            phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

            const x = ORBIT_RADIUS * Math.sin(phi) * Math.sin(theta);
            const y = ORBIT_RADIUS * Math.cos(phi);
            const z = ORBIT_RADIUS * Math.sin(phi) * Math.cos(theta);

            camera.position.set(x, y, z);
            camera.lookAt(0, 0, 0); 

            // 3. Renderizar la Escena
            renderer.render(scene, camera);
        }

        /**
         * Muestra un mensaje temporal en la pantalla (simula un alert, pero con UI).
         */
        function showMessage(text, duration, color) {
            let messageBox = document.getElementById('messageBox');
            if (!messageBox) {
                messageBox = document.createElement('div');
                messageBox.id = 'messageBox';
                messageBox.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 p-3 rounded-lg shadow-xl text-white font-bold transition-opacity duration-300 pointer-events-none opacity-0 z-20';
                document.body.appendChild(messageBox);
            }
            
            messageBox.style.backgroundColor = color ? '#' + color.getHexString() : '#10b981';
            messageBox.textContent = text;
            messageBox.style.opacity = '1';
            
            clearTimeout(messageBox.timer);
            messageBox.timer = setTimeout(() => {
                messageBox.style.opacity = '0';
            }, duration);
        }

        // =================================================================
        // INICIO
        // =================================================================

        document.getElementById('startButton').addEventListener('click', () => {
            startAudioContext(); 
            
            const overlay = document.getElementById('overlay');
            overlay.style.opacity = '0';
            
            setTimeout(() => {
                overlay.style.pointerEvents = 'none';
            }, 500); 
            
            const controls = document.getElementById('controls');
            controls.style.opacity = '1';
            controls.style.pointerEvents = 'auto';

            init();
            animate();
            
            showMessage('¡Simulación Iniciada! Crea sistemas binarios y observa la gravedad.', 3500, new THREE.Color(0x22c55e));
        });

        document.getElementById('clearButton').addEventListener('click', clearSimulation);

    </script>
</body>
</html>
