<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Armonía de las Esferas - Jeopardy</title>
    <!-- Carga de Tailwind CSS para estilos modernos y responsivos -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configuración de Tailwind para incluir colores personalizados
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'space-dark': '#0d0d1a',
                        'space-blue': '#1a202c',
                        // Se define el naranja de la marca para usar en hover/focus
                        'brand-orange': '#f75b0f', 
                        // NUEVO: Color Turquesa para la Trivia
                        'trivia-teal': '#00c7b5',
                    }
                }
            }
        }
    </script>
    <!-- Carga de Three.js para la renderización 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Carga de Tone.js para la generación de audio -->
    <script src="https://unpkg.com/tone@14.7.58/build/Tone.js"></script>
    <style>
        /* Estilos personalizados para el cuerpo y el canvas */
        body {
            margin: 0;
            overflow: hidden; /* Evita barras de desplazamiento */
            font-family: 'Inter', sans-serif;
            background-color: #0d0d1a; /* Fondo oscuro espacial */
        }
        canvas {
            display: block;
            touch-action: none; /* Previene el comportamiento nativo del navegador al arrastrar */
        }
        /* Intenta aumentar el grosor de línea si el navegador lo permite */
        canvas.webgl-canvas {
            stroke-width: 2px;
        }
        /* Estilos específicos para la trivia */
        #jeopardyOverlay {
            /* Se aplica el color de la marca con una ligera opacidad */
            background-color: rgba(247, 91, 15, 0.95); /* #f75b0f */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        .question-card {
            /* Estilo para los botones de las preguntas en el tablero */
            cursor: pointer;
            transition: transform 0.1s, opacity 0.3s;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 1px 1px 2px #000;
        }
        /* APLICA EL EFECTO HOVER DE COLOR TURQUESA */
        .question-card:not(.answered):hover {
            transform: scale(1.05);
            background-color: #14b8a6; /* Usando teal-500 (Turquesa brillante) */
        }
        .answered {
            opacity: 0.5;
            cursor: default;
        }
        #questionDisplay {
            min-height: 20rem; /* Espacio mínimo para la pregunta */
        }
    </style>
</head>
<body>

    <!-- Contenedor del Canvas y Overlay de Instrucciones -->
    <div id="container"></div>

    <!-- Overlay de Inicio -->
    <div id="overlay" style="background-color: #f75b0f;" class="fixed inset-0 flex flex-col items-center justify-center p-4 text-white transition-opacity duration-500 ease-in-out z-30">
        
        <div class="flex flex-col items-center text-center p-4">
            
            <!-- Título principal en color blanco, más grande y prominente -->
            <h1 class="text-6xl sm:text-7xl font-extrabold mb-12 text-white uppercase tracking-wider">
                Armonía de las Esferas
            </h1>
            
            <!-- Botón de inicio en blanco con texto naranja, más grande -->
            <button id="startButton" class="px-10 py-5 bg-white hover:bg-gray-200 text-brand-orange font-extrabold text-xl rounded-xl shadow-2xl transition transform hover:scale-105">
                ¡Empezar Simulación!
            </button>
        </div>
    </div>
    
    <!-- Controles Flotantes -->
    <div id="controls" class="fixed inset-x-0 bottom-4 flex flex-col items-center space-y-3 z-20 opacity-0 transition-opacity duration-500 pointer-events-none sm:flex-row sm:justify-between sm:bottom-auto sm:top-4 sm:space-y-0 sm:px-6">
        
        <!-- Botón Pausar/Reanudar -->
        <div class="sm:order-1 sm:w-auto">
            <button id="pauseButton" class="px-5 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50">
                Pausar Simulación
            </button>
        </div>
        
        <!-- Selector de SONIDO RÍTMICO -->
        <div class="w-full sm:w-auto sm:order-2">
            <label for="rhythmSoundSelect" class="block text-sm font-medium text-white mb-1">Pulso Planeta:</label>
            <select id="rhythmSoundSelect" class="w-full sm:w-36 p-2 bg-gray-800 text-white rounded-lg border border-gray-700 focus:ring-brand-orange focus:border-brand-orange transition duration-150">
                <option value="melodic">Melódico (Continua)</option>
                <option value="percussive_bell">Tambor (Percusivo)</option>
                <option value="pulse_bass">Bajo (Sub-Bass)</option>
                <option value="glissando">Glissando (Barrido)</option>
                <option value="filtered_noise">Ruido (Filtrado)</option>
            </select>
        </div>

        <!-- Menú de Selección de Entidad -->
        <div class="w-full sm:w-auto sm:order-3">
            <label for="entitySelect" class="block text-sm font-medium text-white mb-1">Crear:</label>
            <select id="entitySelect" class="w-full sm:w-36 p-2 bg-gray-800 text-white rounded-lg border border-gray-700 focus:ring-brand-orange focus:border-brand-orange transition duration-150">
                <option value="planet">Planeta</option>
                <option value="sun">Sol</option>
            </option>
            </select>
        </div>

        <!-- Botón Reiniciar Simulación (Bottom-Center) -->
        <div class="sm:order-4 sm:w-auto">
            <button id="clearButton" style="background-color: #f75b0f;" class="px-5 py-3 hover:bg-orange-700 text-white font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-orange-500 focus:ring-opacity-50">
                Reiniciar Simulación
            </button>
        </div>

        <!-- Botón Iniciar Trivia (NUEVO) -->
        <div class="sm:order-5 sm:w-auto">
            <button id="triviaButton" class="px-5 py-3 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-yellow-400 focus:ring-opacity-50">
                Iniciar Trivia
            </button>
        </div>
    </div>

    <!-- Overlay de JEOPARDY (Inicialmente Oculto) -->
    <div id="jeopardyOverlay" class="fixed inset-0 flex flex-col items-center justify-center p-4 text-white z-40 hidden">
        <div id="triviaContent" class="w-full max-w-6xl bg-gray-900/90 rounded-xl shadow-2xl p-6 space-y-6">
            
            <!-- Encabezado y Puntuación -->
            <div class="flex justify-between items-center border-b pb-3 border-gray-700">
                <!-- Título Simplificado -->
                <h2 class="text-3xl font-bold text-yellow-400">Armonía de las Esferas</h2>
                <div id="score" class="text-lg font-medium bg-gray-800 p-2 rounded-lg">
                    Puntos: <span id="currentScore" class="text-yellow-400">0</span>
                </div>
                <!-- Botón Regresar - Llama a resumeSimulation() -->
                <button id="resumeButton" class="px-4 py-2 bg-trivia-teal hover:bg-teal-600 rounded-lg text-white font-semibold transition">Regresar</button>
            </div>
            
            <!-- Contenedor del Tablero (Grid) -->
            <div id="jeopardyBoard" class="grid grid-cols-3 gap-3">
                <!-- Títulos de Categoría -->
                <div class="p-3 bg-trivia-teal font-extrabold text-xl text-center rounded-t-lg text-white">FÍSICA (Gravedad)</div>
                <div class="p-3 bg-trivia-teal font-extrabold text-xl text-center rounded-t-lg text-white">COMPOSICIÓN</div>
                <div class="p-3 bg-trivia-teal font-extrabold text-xl text-center rounded-t-lg text-white">DATOS DEL SISTEMA</div>
                
                <!-- Las celdas de puntos se inyectan aquí -->
            </div>
            
            <!-- Contenedor de la Pregunta Activa -->
            <div id="questionDisplay" class="hidden flex-col justify-center items-center p-6 bg-white text-gray-900 rounded-lg question-card">
                <div id="questionCategory" class="text-xl font-semibold text-yellow-600 mb-2"></div>
                <div id="questionValue" class="2xl font-bold mb-4"></div>
                <div id="currentQuestionText" class="text-2xl text-center mb-6"></div>
                
                <div id="optionsContainer" class="w-full grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Opciones de respuesta inyectadas aquí -->
                </div>
                
                <div id="feedbackMessage" class="mt-4 text-xl font-bold hidden"></div>
                <!-- Botón Volver al Tablero - Llama a renderJeopardyBoard() -->
                <button id="backToBoardButton" class="mt-6 px-6 py-3 bg-trivia-teal hover:bg-teal-600 rounded-lg text-white font-semibold transition hidden">Volver al Tablero</button>
            </div>
            

        </div>
    </div>


    <script>
        // Configuración global de Three.js
        let scene, camera, renderer;
        let ambientLight;
        let starField; // Variable para el campo de estrellas
        
        // --- ARRAYS GLOBALES PARA MÚLTIPLES OBJETOS ---
        const suns = []; 
        const planets = [];
        
        // =================================================================
        // CONSTANTES DE FÍSICA Y TIEMPO
        // =================================================================
        const GRAVITATIONAL_CONSTANT = 1.0; 
        const SUN_MASS = 1000.0; 
        const PLANET_MASS = 1.0; 
        const TIME_STEP = 0.05; 
        const MIN_DISTANCE = 25;
        const MAX_DISTANCE = 150;
        const COLLISION_DISTANCE = 18; 
        const MAX_SUN_DISTANCE = 100; 
        
        // Aumentamos la longitud del rastro a 100 puntos (antes 50)
        const TRAIL_LENGTH = 100; 
        
        // NUEVA VARIABLE DE ESTADO
        let isPaused = false;
        
        // Objeto para ayudar en la conversión de coordenadas 2D a 3D
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        
        // Vectores temporales para evitar reasignaciones constantes y ahorrar memoria/rendimiento
        const tempVector = new THREE.Vector3();
        
        // =================================================================
        // VARIABLES DE CONTROL DE CÁMARA (MANUAL)
        // =================================================================
        let isDragging = false; 
        let isPointerActive = false;
        let pointerStart = { x: 0, y: 0 };
        let previousPointerPosition = { x: 0, y: 0 };
        const ORBIT_RADIUS = 150; 
        
        let theta = 0; 
        let phi = Math.PI / 2;
        
        const DAMPING_FACTOR = 0.9; 
        const ROTATION_MULTIPLIER = 0.005;
        let velocityX = 0;
        let velocityY = 0;
        
        const DRAG_THRESHOLD = 5;

        // =================================================================
        // CONFIGURACIÓN DE AUDIO (TONE.JS)
        // =================================================================
        let isAudioContextStarted = false;

        // Rango de Frecuencias (en Hz) para el mapeo dinámico
        const MIN_FREQ = 65.41; // C2 (Nota más grave)
        const MAX_FREQ = 261.63; // C4 (Nota más aguda, pero aún suave)
        
        // Variables para el control de ritmo
        let audioClock = 0;
        const RHYTHM_STEP = 0.5; // El tiempo que debe pasar en el audio para actualizar el reloj
        const RHYTHM_MULTIPLIER = 0.02; // Velocidad del reloj interno
        
        // Sintetizadores globales para los pulsos (que no cambian de estado)
        let basicPulseSynth; 
        let drumSynth; // Sintetizador de Percusión Dinámica (Tambor)
        let subBassSynth; // Sintetizador de Bajo (Sub-Bass)
        let glissandoSynth; // Sintetizador de Glissando (Barrido de Tono)
        let filteredNoiseSynth; // Nuevo: Sintetizador de Ruido Filtrado

        // Se inicializa una reverberación para dar un ambiente espacial a todos los sonidos
        const reverb = new Tone.Reverb({
            decay: 2.5,
            preDelay: 0.02,
            wet: 0.3 
        }).toDestination();


        /**
         * Inicializa los sintetizadores de pulso rítmico.
         */
        function setupAudio() {
             // 1. Pulso Básico (Sine wave bajo y corto - Ritmo fijo)
             const basicConfig = {
                oscillator: { type: "sine" }, 
                envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 },
                volume: -15 
            };
            basicPulseSynth = new Tone.Synth(basicConfig).toDestination();
            
            // 2. Tambor (Percusivo) - Usando FMSynth para un sonido percusivo más suave y armónico
             drumSynth = new Tone.FMSynth({
                oscillator: { type: "sine" },
                envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 },
                modulation: { type: "triangle" }, // Modulación para añadir riqueza armónica
                modulationEnvelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 },
                modulationIndex: 1, 
                harmonicity: 1.5,
                volume: -5 // Aumento de volumen de -8 a -5
            }).connect(reverb);
            
            // 3. Bajo (Sub-Bass) - Usando onda triangular para un bajo suave y profundo
            subBassSynth = new Tone.Synth({
                oscillator: { type: "triangle" }, 
                envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 },
                volume: -10 // Aumentado de -15 a -10 dB
            }).toDestination();

            // 4. Glissando (Barrido de Tono) - Usando Synth con onda de sierra para un barrido rico
            glissandoSynth = new Tone.Synth({
                oscillator: { type: "sawtooth" }, // Onda de sierra para un timbre rico
                envelope: { attack: 0.01, decay: 0.8, sustain: 0.0, release: 0.1 }, // Rápido ataque y decaimiento
                volume: -18 // Volumen reducido de -10 a -18 dB
            }).toDestination();

            // 5. Ruido Filtrado (Textura)
            filteredNoiseSynth = new Tone.NoiseSynth({
                noise: { type: "brown" }, // Ruido marrón (más grave y suave)
                envelope: { attack: 0.01, decay: 0.2, sustain: 0.0, release: 0.2 },
                filter: { type: "bandpass", frequency: 1000, Q: 1.5 }, // Filtro de paso de banda
                volume: -15
            }).toDestination();
        }


        /**
         * Crea el sintetizador único de tono continuo (onda sinusoidal) y el panner.
         * ESTE ES EL SINTETIZADOR DE MELODÍA CONTINUA.
         * @returns {object} Un objeto con la instancia del sintetizador y el panner.
         */
        function createSynth() {
            // Configuración para un sonido de onda sinusoidal (sine)
            const config = {
                oscillator: { type: "sine" }, // Onda Sinusoidal
                envelope: { 
                    attack: 0.05, 
                    decay: 0.5, 
                    sustain: 1.0, // Sostenido alto para sonido continuo
                    release: 1.5 // El release largo
                },
                volume: -15 // Volumen base ligeramente más bajo
            };
            
            const panner = new Tone.Panner().connect(reverb);
            const synthInstance = new Tone.Synth(config).connect(panner);
            return { synth: synthInstance, panner: panner };
        }


        /**
         * Inicializa el AudioContext de Tone.js después del primer toque del usuario.
         */
        function startAudioContext() {
            if (!isAudioContextStarted) {
                Tone.start(); 
                isAudioContextStarted = true;
                setupAudio(); // Inicializa los synths de pulso
            }
        }

        // =================================================================
        // FUNCIONES DE FÍSICA
        // =================================================================

        /**
         * Calcula la aceleración gravitacional neta sobre el planeta causada por todos los soles.
         * F = G * M1 * M2 / r^2
         * A = F / M2 = G * M1 / r^2
         * @param {object} planet El objeto planeta con posición, masa y aceleración.
         */
        function calculateGravity(planet) {
            const netAcceleration = new THREE.Vector3(0, 0, 0);

            suns.forEach(sun => {
                // Vector que apunta del planeta al sol
                // Usamos sun.mesh.position porque es la instancia THREE.Vector3 del mesh.
                const direction = tempVector.copy(sun.mesh.position).sub(planet.mesh.position);
                const distanceSq = direction.lengthSq();

                // Evitar división por cero o fuerzas infinitas en colisión cercana
                if (distanceSq < 1) { 
                    return;
                }
                
                const distance = Math.sqrt(distanceSq);

                // Fuerza gravitacional: A = (G * M_sol / r^2) * (vector unitario)
                const magnitude = (GRAVITATIONAL_CONSTANT * SUN_MASS) / distanceSq;

                // Asegurar que la fuerza no sea demasiado grande a corta distancia
                const maxMagnitude = 5.0; // Límite de aceleración para estabilidad
                const finalMagnitude = Math.min(magnitude, maxMagnitude);

                direction.normalize().multiplyScalar(finalMagnitude);
                
                netAcceleration.add(direction);
            });

            planet.acceleration = netAcceleration;
        }

        /**
         * Aplica la integración de Euler para actualizar la velocidad y posición.
         * @param {object} planet El objeto planeta.
         * @param {number} deltaTime El paso de tiempo.
         */
        function updatePhysics(planet, deltaTime) {
            // Velocidad = Velocidad + Aceleración * dt
            planet.velocity.add(planet.acceleration.clone().multiplyScalar(deltaTime));
            
            // Posición = Posición + Velocidad * dt
            planet.mesh.position.add(planet.velocity.clone().multiplyScalar(deltaTime));
        }

        /**
         * Encuentra el Sol más cercano al punto de click.
         * @param {THREE.Vector3} clickPosition Posición 3D del click.
         * @returns {object} El objeto Sol más cercano.
         */
        function findNearestSun(clickPosition) {
            let minDistanceSq = Infinity;
            let nearestSun = null;
            
            suns.forEach(sun => {
                // Usamos subVectors y lengthSq para calcular la distancia.
                const diffVector = new THREE.Vector3().subVectors(sun.mesh.position, clickPosition);
                const distanceSq = diffVector.lengthSq(); 
                
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    nearestSun = sun;
                }
            });

            return nearestSun;
        }

        // =================================================================
        // UTILIDADES
        // =================================================================

        /**
         * Inicializa la escena, cámara, renderizador y luces.
         */
        function init() {
            // 1. Configuración de la Escena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0d0d1a, 0.003); 

            // 2. Configuración de la Cámara (perspectiva para 3D)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, ORBIT_RADIUS); // Posición inicial
            
            // 3. Configuración del Renderizador (WebGL)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
            // Añadir una clase para apuntar con CSS si queremos aumentar el grosor de línea
            renderer.domElement.classList.add('webgl-canvas'); 
            document.getElementById('container').appendChild(renderer.domElement);
            
            // 4. Configuración de la Iluminación
            ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
            scene.add(ambientLight);

            // 5. Crear el Sol Central Inicial y el Fondo de Estrellas
            createInitialSun(); 
            createStarField(); 
            
            // 6. Manejadores de Eventos
            window.addEventListener('resize', onWindowResize, false);
            setupPointerControls(renderer.domElement);
            
            // MOVEMOS EL EVENTO DE PAUSA/REINICIAR AL START BUTTON LISTENER
        }

        /**
         * Crea el primer Sol al iniciar la simulación.
         */
        function createInitialSun() {
            const center = new THREE.Vector3(0, 0, 0);
            createSunAtPosition(center);
        }

        /**
         * Crea un objeto Sol y lo añade a la escena y al array de Soles.
         * @param {THREE.Vector3} position Posición del nuevo sol.
         */
        function createSunAtPosition(position) {
            const sunRadius = 12;
            const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32); 
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                emissive: 0xff8800 
            }); 
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.copy(position);
            scene.add(sunMesh);
            
            const flareTexture = generateRadialTexture(); 

            const lightSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: flareTexture,
                color: 0xff8800, 
                blending: THREE.AdditiveBlending, 
                transparent: true,
                opacity: 0.7 
            }));
            lightSprite.scale.set(50, 50, 1.0); 
            sunMesh.add(lightSprite);

            // Cada sol necesita una luz para iluminar a los planetas a su alrededor
            const sunLight = new THREE.PointLight(0xffffff, 3.0, 0, 0); 
            sunLight.position.copy(position);
            scene.add(sunLight);

            // Se almacena el mesh para acceder a su posición Vector3
            suns.push({ mesh: sunMesh, light: sunLight, mass: SUN_MASS });
        }


        /**
         * Crea un campo de estrellas aleatorias para el fondo.
         */
        function createStarField() {
            const starCount = 1500;
            const starGeometry = new THREE.BufferGeometry();
            const positions = [];
            
            const radius = 500; 

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(radius * 2);
                const y = THREE.MathUtils.randFloatSpread(radius * 2);
                const z = THREE.MathUtils.randFloatSpread(radius * 2);

                positions.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1, 
                sizeAttenuation: true 
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }
        
        /**
         * Genera una textura circular suave con degradado para simular un brillo (flare).
         */
        function generateRadialTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');

            const gradient = context.createRadialGradient(
                size / 2, size / 2, 0, 
                size / 2, size / 2, size / 2 
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)'); 
            gradient.addColorStop(1, 'rgba(255,255,255,0)'); 

            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);

            return new THREE.CanvasTexture(canvas);
        }

        /**
         * Configura los eventos de mouse y touch para el control de la cámara.
         */
        function setupPointerControls(element) {
            element.addEventListener('pointerdown', onPointerDown, false);
            element.addEventListener('pointermove', onPointerMove, false);
            element.addEventListener('pointerup', onPointerUp, false);
            element.addEventListener('pointerleave', onPointerUp, false);
        }

        /**
         * Evento al pulsar (clic o tocar).
         */
        function onPointerDown(event) {
            if (event.buttons === 1 || event.pointerType === 'touch') { 
                isPointerActive = true; 
                isDragging = false; 
                
                pointerStart.x = event.clientX;
                pointerStart.y = event.clientY;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
                velocityX = 0;
                velocityY = 0;
            }
        }

        /**
         * Evento al mover el puntero (arrastrar).
         */
        function onPointerMove(event) {
            
            if (!isPointerActive) return; 

            if (!isDragging) {
                const deltaMovementX = event.clientX - pointerStart.x;
                const deltaMovementY = event.clientY - pointerStart.y;
                const distance = Math.sqrt(deltaMovementX * deltaMovementX + deltaMovementY * deltaMovementY); 
                
                if (distance > DRAG_THRESHOLD) {
                    isDragging = true; 
                }
            }

            if (isDragging) { 
                const deltaX = event.clientX - previousPointerPosition.x;
                const deltaY = event.clientY - previousPointerPosition.y;

                theta += deltaX * ROTATION_MULTIPLIER;
                phi -= deltaY * ROTATION_MULTIPLIER;
                
                velocityX = deltaX * ROTATION_MULTIPLIER * 0.5;
                velocityY = deltaY * ROTATION_MULTIPLIER * 0.5;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
            }
        }

        /**
         * Evento al soltar (dejar de arrastrar o crear entidad).
         */
        function onPointerUp(event) {
            if (isPointerActive && !isDragging) { 
                const entitySelect = document.getElementById('entitySelect');
                const selectedEntity = entitySelect ? entitySelect.value : 'planet';
                
                if (selectedEntity === 'planet') {
                    createPlanet(event);
                } else if (selectedEntity === 'sun') {
                    createSunOnClick(event);
                }
            }
            
            isDragging = false; 
            isPointerActive = false; 
        }

        /**
         * Intenta crear un Sol en la posición del click/toque.
         */
        function createSunOnClick(event) {
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);

            // Limitar la distancia del Sol para evitar que aparezca muy lejos
            if (intersection.length() > MAX_SUN_DISTANCE) {
                intersection.normalize().multiplyScalar(MAX_SUN_DISTANCE);
                showMessage('Sol colocado en el límite de la zona central.', 2000, new THREE.Color(0xfacc15));
            }


            createSunAtPosition(intersection);
            showMessage('¡Nuevo Sol Creado! Ahora afecta la gravedad.', 2000, new THREE.Color(0xfacc15));
        }

        /**
         * Crea un nuevo planeta.
         * @param {PointerEvent} event El evento de puntero (contiene clientX/Y).
         */
        function createPlanet(event) {
            startAudioContext(); 

            if (suns.length === 0) {
                showMessage('No hay soles para orbitar. ¡Crea un Sol primero!', 3000, new THREE.Color(0xef4444));
                return;
            }

            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);
            const initialPosition = intersection.clone();

            // --- 1. ENCONTRAR EL SOL MÁS CERCANO PARA INICIALIZAR LA ÓRBITA ---
            const nearestSun = findNearestSun(initialPosition);
            
            // Usamos la posición del mesh del sol para la física
            const relativePosition = initialPosition.clone().sub(nearestSun.mesh.position);
            const distance = relativePosition.length();

            if (distance < COLLISION_DISTANCE) {
                showMessage('Demasiado cerca del Sol. Intenta más lejos.', 3000, new THREE.Color(0xfacc15));
                return;
            }

            // 2. CÁLCULO DE VELOCIDAD INICIAL (para órbita circular aproximada alrededor del Sol más cercano)
            
            // Magnitud de la velocidad orbital: v = sqrt(G*M/r)
            const orbitVelocityMag = Math.sqrt((GRAVITATIONAL_CONSTANT * SUN_MASS) / distance);
            
            // Dirección de la velocidad: perpendicular al vector posición (para iniciar la órbita)
            const positionUnit = relativePosition.clone().normalize();
            
            // Usa el producto cruz con el vector 'up' (Y=1) para obtener una velocidad tangencial
            let initialVelocity = new THREE.Vector3().crossVectors(positionUnit, new THREE.Vector3(0, 1, 0));
            
            // Si el producto cruz es casi cero (el planeta está en Y, que no debería pasar aquí)
            if (initialVelocity.lengthSq() < 0.001) {
                initialVelocity.set(1, 0, 0); 
            }
            
            // Velocidad inicial más ajustada (0.95 a 1.05) para asegurar una órbita estable
            initialVelocity.normalize().multiplyScalar(orbitVelocityMag * THREE.MathUtils.randFloat(0.95, 1.05));

            // Añadir una pequeña componente Y para dar una inclinación 3D inicial
            initialVelocity.y = THREE.MathUtils.randFloatSpread(orbitVelocityMag * 0.1); 

            // 3. GENERAR EL RESTO DE PROPIEDADES
            const radius = THREE.MathUtils.randFloat(1, 4); 
            
            const baseColor = new THREE.Color(Math.random(), Math.random(), Math.random());
            const hsl = {};
            baseColor.getHSL(hsl);
            hsl.l = THREE.MathUtils.randFloat(0.7, 0.9);
            hsl.s = THREE.MathUtils.randFloat(0.4, 0.8); 
            const brightColor = new THREE.Color().setHSL(hsl.h, hsl.s, hsl.l);


            // 4. Configuración de AUDIO
            const { synth, panner } = createSynth(); // Usamos panner
            
            // Lógica de nota inicial (solo para referencia, la frecuencia será dinámica)
            const distanceRange = MAX_DISTANCE - MIN_DISTANCE;
            const distanceRatio = (distance - MIN_DISTANCE) / distanceRange;
            const initialFrequency = THREE.MathUtils.mapLinear(distanceRatio, 0, 1, MAX_FREQ, MIN_FREQ); // Inversa: Cerca = Agudo, Lejos = Grave

            
            // --- NUEVAS VARIABLES DE RITMO Y SONIDO ---
            const rhythmOptions = [4, 8, 16, 32]; // Opciones rítmicas (por ejemplo, 1/4, 1/8, 1/16, etc.)
            const rhythm = rhythmOptions[Math.floor(Math.random() * rhythmOptions.length)]; 
            const baseVolume = THREE.MathUtils.randFloat(-10, -5); // -10dB a -5dB
            
            
            // Obtener el tipo de pulso seleccionado en el menú
            const rhythmSoundSelect = document.getElementById('rhythmSoundSelect');
            const pulseType = rhythmSoundSelect ? rhythmSoundSelect.value : 'melodic';
            
            // CONTROL DE MELODÍA CONTINUA
            if (pulseType !== 'melodic') {
                synth.volume.value = -100; // Silencia la melodía si es un modo rítmico
            } else {
                synth.volume.value = baseVolume; // Establece el volumen base para la melodía continua
            }


            // 5. Malla y Rastro (similar al código anterior)
            const planetGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const planetMaterial = new THREE.MeshLambertMaterial({ 
                color: brightColor, 
                emissive: brightColor.clone().multiplyScalar(0.1) 
            });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
            planetMesh.position.copy(initialPosition);

            const orbitPositions = new Float32Array(TRAIL_LENGTH * 3); 
            const drawingPositions = new Float32Array(TRAIL_LENGTH * 3);
            
            // Creación del Array de Colores (RGBA: 4 componentes por punto)
            const trailColors = new Float32Array(TRAIL_LENGTH * 4); 

            const trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(drawingPositions, 3)); 
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 4)); // Añadir atributo de color/opacidad
            
            const trailMaterial = new THREE.LineBasicMaterial({
                color: brightColor, 
                transparent: true,
                opacity: 1.0,
                vertexColors: true // Usar colores definidos por el vértice
            });
            const orbitTrail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(orbitTrail);

            // 6. Crear Objeto para el planeta (PROPIEDADES DE FÍSICA Y AUDIO)
            const planetObject = {
                mesh: planetMesh,
                trail: orbitTrail,
                orbitPositions: orbitPositions, 
                trailColors: trailColors, // Almacenar el array de colores
                planetColor: brightColor, // Color base del planeta
                trailIndex: 0,
                trailLength: TRAIL_LENGTH,
                trailCount: 0,
                // PROPIEDADES DE FÍSICA
                mass: PLANET_MASS,
                velocity: initialVelocity, // Vector3
                acceleration: new THREE.Vector3(0, 0, 0), // Vector3
                // PROPIEDADES DE AUDIO
                synth: synth,
                panner: panner, // Nuevo panner
                rhythm: rhythm, // Nuevo ritmo
                rhythmCounter: 0, // Contador interno para el ritmo
                pulseType: pulseType, // Tipo de pulso (melodic, percussive_bell, pulse_bass, glissando, filtered_noise)
                initialFrequency: initialFrequency, 
                isPlaying: false, 
                lastPulseTime: Date.now(), // Nuevo: tiempo del último golpe para ritmo dinámico
                // PROPIEDADES DE TRIVIA
                id: planets.length + 1, // Asignar un ID para identificarlo en la trivia
                pulseTypeName: rhythmSoundSelect.options[rhythmSoundSelect.selectedIndex].text // Nombre legible del pulso
            };

            scene.add(planetMesh);
            planets.push(planetObject);
            
            // INICIAMOS EL SONIDO AL CREAR EL PLANETA
            planetObject.synth.triggerAttack(initialFrequency); // Iniciamos el ataque con la frecuencia inicial
            planetObject.isPlaying = true;

            showMessage(`¡Planeta Creado con Pulso ${pulseType}!`, 1500, brightColor);
        }

        /**
         * Alterna el estado de pausa de la simulación y la música.
         */
        function togglePause() {
            isPaused = !isPaused;
            const button = document.getElementById('pauseButton');
            
            if (isPaused) {
                button.textContent = 'Reanudar Simulación';
                button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                button.classList.add('bg-green-600', 'hover:bg-green-700');
                Tone.Master.mute = true;
                showMessage('Simulación PAUSADA.', 1500, new THREE.Color(0xfb923c));
            } else {
                button.textContent = 'Pausar Simulación';
                button.classList.remove('bg-green-600', 'hover:bg-green-700');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700');
                Tone.Master.mute = false;
                showMessage('Simulación REANUDADA.', 1500, new THREE.Color(0x22c55e));
            }
        }

        /**
         * Elimina todos los planetas, soles, sus rastros y sus sintetizadores.
         */
        function clearSimulation() {
            const initialSuns = suns.length;
            
            if (isPaused) {
                togglePause(); // Asegura reanudar si estaba pausado
            }
            
            // Detener el audio de todos los planetas antes de eliminarlos
            planets.forEach(planet => {
                if (planet.synth && planet.isPlaying) {
                    planet.synth.triggerRelease();
                }
            });

            // Limpieza de Planetas
            planets.forEach(planet => {
                if (planet.synth) planet.synth.dispose();
                scene.remove(planet.mesh);
                scene.remove(planet.trail);
            });
            planets.length = 0;

            // Limpieza de Soles
            suns.forEach(sun => {
                scene.remove(sun.mesh);
                scene.remove(sun.light);
            });
            suns.length = 0;
            
            // Vuelve a crear el sol inicial
            if (initialSuns === 0) {
                 createInitialSun(); 
            }
            
            audioClock = 0; // Reiniciar el reloj de audio

            showMessage('Simulación Reiniciada. ¡Crea nuevos sistemas!', 2500, new THREE.Color(0xef4444));
        }

        /**
         * Maneja el redimensionamiento de la ventana para mantener la vista correcta.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * Bucle principal de animación (game loop).
         */
        function animate() {
            requestAnimationFrame(animate);
            
            // 0. Rotación sutil del campo de estrellas
            if (starField) {
                starField.rotation.y += 0.00005; 
            }

            // 1. Mover Planetas y Actualizar Rastros y Audio (SOLO si NO está pausado)
            if (!isPaused) {
                // Actualizar el reloj de audio global (SOLO usado por el pulso 'basic')
                audioClock += RHYTHM_MULTIPLIER;
                if (audioClock >= RHYTHM_STEP * 32) { // 32 es el múltiplo más grande de los ritmos
                    audioClock = 0;
                }

                const currentTime = Date.now(); // Tiempo actual para el pulso dinámico

                for (let i = planets.length - 1; i >= 0; i--) {
                    const planet = planets[i];

                    // a. Calcular fuerzas y actualizar física
                    calculateGravity(planet);
                    updatePhysics(planet, TIME_STEP);
                    
                    // b. Detección de colisión (Ya no elimina) / expulsión (SOLO ELIMINA POR EXPULSIÓN)
                    if (planet.mesh.position.length() > 300) {
                        // Expulsión: Eliminar planeta
                        if (planet.synth) {
                            planet.synth.triggerRelease(); // Suelta la nota
                            planet.synth.dispose();
                        }
                        scene.remove(planet.mesh);
                        scene.remove(planet.trail);
                        planets.splice(i, 1);
                        showMessage('¡Planeta Escapado! Limpiado.', 1000, new THREE.Color(0xff4444));
                        continue; // Pasa al siguiente planeta
                    }


                    // c. LÓGICA DE AUDIO DINÁMICO Y RÍTMICO
                    
                    const nearestSun = findNearestSun(planet.mesh.position);
                    
                    if (nearestSun) {
                        const relativePosition = tempVector.copy(planet.mesh.position).sub(nearestSun.mesh.position);
                        const distance = relativePosition.length();
                        
                        // --- Mapeo de Frecuencia (PITCH/TONO) ---
                        const distanceClamped = THREE.MathUtils.clamp(distance, MIN_DISTANCE, MAX_DISTANCE);
                        const distanceRatio = THREE.MathUtils.mapLinear(distanceClamped, MIN_DISTANCE, MAX_DISTANCE, 0, 1);
                        const currentFrequency = THREE.MathUtils.mapLinear(distanceRatio, 0, 1, MAX_FREQ, MIN_FREQ);
                        
                        // Si el planeta no está silenciado, modula la frecuencia
                        if (planet.synth.volume.value > -99) {
                            planet.synth.frequency.rampTo(currentFrequency, 0.05);
                        }

                        // --- Mapeo de Panoramización (PANNING) ---
                        const panValue = THREE.MathUtils.clamp(relativePosition.x / MAX_DISTANCE, -1, 1);
                        planet.panner.pan.rampTo(panValue, 0.1); 


                        // --- Lógica Rítmica (PULSO) ---
                        
                        const rhythmUnit = RHYTHM_STEP * planet.rhythm;
                        const isTriggerTime = audioClock % rhythmUnit < RHYTHM_MULTIPLIER;
                        
                        if (planet.pulseType === 'melodic') {
                            // RITMO FIJO (Pulso de fondo para la melodía continua)
                            // AÑADIDO: Pulso más complejo (C1, G1, C2) para más movimiento rítmico
                            if (audioClock % (RHYTHM_STEP * 4) < RHYTHM_MULTIPLIER) {
                                basicPulseSynth.triggerAttackRelease('C1', '16n'); 
                            }
                            if (audioClock % (RHYTHM_STEP * 8) < RHYTHM_MULTIPLIER) {
                                basicPulseSynth.triggerAttackRelease('G1', '16n', Tone.now() + 0.05); // Ligeramente desfasado
                            }
                            if (audioClock % (RHYTHM_STEP * 16) < RHYTHM_MULTIPLIER) {
                                basicPulseSynth.triggerAttackRelease('C2', '16n', Tone.now() + 0.1); 
                            }
                            
                        } else if (planet.pulseType === 'percussive_bell') {
                            // PERCUSIVO (TAMBOR) - Ritmo Dinámico afectado por la gravedad (velocidad)
                            
                            const velocityRatio = 1.0 - distanceRatio; 
                            const minInterval = 0.2; 
                            const maxInterval = 2.0; 
                            const currentInterval = THREE.MathUtils.mapLinear(velocityRatio, 0, 1, maxInterval, minInterval);

                            if (currentTime - planet.lastPulseTime >= currentInterval * 1000) {
                                // Tono Tambor: Dinámico
                                const drumFrequency = THREE.MathUtils.mapLinear(distanceRatio, 0, 1, 300, 100); 
                                
                                drumSynth.triggerAttackRelease(drumFrequency, "8n");
                                
                                planet.lastPulseTime = currentTime;
                            }
                            
                        } else if (planet.pulseType === 'pulse_bass') {
                            // BAJO (SUB-BASS) - Ritmo Fijo y Lento
                            // Solo se dispara en el pulso más lento (1/4 o 1/2) para ser la base rítmica
                            if (audioClock % (RHYTHM_STEP * 8) < RHYTHM_MULTIPLIER) {
                                
                                // Tono Bajo: Dinámico
                                const bassFrequency = THREE.MathUtils.mapLinear(distanceRatio, 0, 1, 60, 20); // Notas muy graves 
                                
                                subBassSynth.triggerAttackRelease(bassFrequency, "4n");
                            }
                        } else if (planet.pulseType === 'glissando') {
                            // GLISSANDO (BARRIDO) - Pulso Rítmico con barrido de tono
                            if (audioClock % (RHYTHM_STEP * 8) < RHYTHM_MULTIPLIER) {
                                // Dispara una nota baja y la barre rápidamente a una nota alta
                                glissandoSynth.triggerAttack(Tone.Midi(36)); // C2 (grave)
                                glissandoSynth.frequency.linearRampToValueAtTime(Tone.Midi(48), Tone.now() + 0.3); // Barre a C3
                                glissandoSynth.triggerRelease(Tone.now() + 0.4); 
                            }
                        } else if (planet.pulseType === 'filtered_noise') {
                            // RUIDO FILTRADO (TEXTURA) - Ruido que se mueve con la distancia
                            if (audioClock % (RHYTHM_STEP * 4) < RHYTHM_MULTIPLIER) {
                                filteredNoiseSynth.triggerAttackRelease('16n');

                                // Modula la frecuencia de corte del filtro con la distancia
                                const filterFrequency = THREE.MathUtils.mapLinear(distanceRatio, 0, 1, 10000, 500); // 500Hz (Lejos) a 10000Hz (Cerca)
                                filteredNoiseSynth.filter.frequency.rampTo(filterFrequency, 0.1);
                            }
                        }
                    }


                    // d. Rotación propia del planeta
                    planet.mesh.rotation.y += 0.01;

                    // e. Actualizar rastro de órbita y colores (opacidad)
                    const orbitPositions = planet.orbitPositions;
                    const positionsAttribute = planet.trail.geometry.attributes.position;
                    const colorsAttribute = planet.trail.geometry.attributes.color;
                    const positionsForDrawing = positionsAttribute.array;
                    const colorsForDrawing = colorsAttribute.array;
                    
                    const index = planet.trailIndex * 3;

                    // 1. Guardar nueva posición
                    orbitPositions[index] = planet.mesh.position.x;
                    orbitPositions[index + 1] = planet.mesh.position.y;
                    orbitPositions[index + 2] = planet.mesh.position.z;

                    planet.trailIndex = (planet.trailIndex + 1) % planet.trailLength;
                    
                    if (planet.trailCount < planet.trailLength) {
                        planet.trailCount++;
                    }

                    // 2. Reordenar puntos y aplicar colores/opacidad
                    let p_index = 0; 
                    const totalPoints = planet.trailCount < planet.trailLength ? planet.trailCount : planet.trailLength;
                    const baseColor = planet.planetColor;

                    const updatePoint = (j, opacityRatio) => {
                        // Posición
                        positionsForDrawing[p_index * 3] = orbitPositions[j * 3];
                        positionsForDrawing[p_index * 3 + 1] = orbitPositions[j * 3 + 1];
                        positionsForDrawing[p_index * 3 + 2] = orbitPositions[j * 3 + 2];
                        
                        // Color y Opacidad (RGBA)
                        colorsForDrawing[p_index * 4] = baseColor.r;
                        colorsForDrawing[p_index * 4 + 1] = baseColor.g;
                        colorsForDrawing[p_index * 4 + 2] = baseColor.b;
                        colorsForDrawing[p_index * 4 + 3] = opacityRatio; // Opacidad

                        p_index++;
                    };
                    
                    const calculateOpacity = (i) => {
                        // i: índice absoluto del punto, de 0 al totalPoints-1
                        const minOpacity = 0.2;
                        const factor = 1.0 - minOpacity;
                        return minOpacity + (i / totalPoints) * factor; 
                    };


                    if (planet.trailCount < planet.trailLength) {
                        // FASE DE LLENADO: Rastro desde el punto 0 hasta el punto actual
                        for (let j = 0; j < planet.trailCount; j++) {
                            const opacityRatio = calculateOpacity(j);
                            updatePoint(j, opacityRatio);
                        }
                        planet.trail.geometry.setDrawRange(0, planet.trailCount);

                    } else {
                        // FASE ESTABLE: Rastro completo (buffer circular)
                        let opacityCounter = 0;
                        
                        // Parte A: Desde el punto actual (el más viejo) hasta el final del array
                        for (let j = planet.trailIndex; j < planet.trailLength; j++) {
                            const opacityRatio = calculateOpacity(opacityCounter++);
                            updatePoint(j, opacityRatio);
                        }
                        // Parte B: Desde el inicio del array (punto 0) hasta el punto actual (el más reciente)
                        for (let j = 0; j < planet.trailIndex; j++) {
                            const opacityRatio = calculateOpacity(opacityCounter++);
                            updatePoint(j, opacityRatio);
                        }
                        
                        planet.trail.geometry.setDrawRange(0, planet.trailLength);
                    }

                    positionsAttribute.needsUpdate = true;
                    colorsAttribute.needsUpdate = true; // Notificar a Three.js que los colores cambiaron
                }
            }
            
            // 2. Mover la Cámara (Controles Manuales e Inercia) - Esto siempre debe funcionar
            if (!isDragging) {
                theta += velocityX;
                phi -= velocityY; 
                velocityX *= DAMPING_FACTOR;
                velocityY *= DAMPING_FACTOR;
            }

            phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

            const x = ORBIT_RADIUS * Math.sin(phi) * Math.sin(theta);
            const y = ORBIT_RADIUS * Math.cos(phi);
            const z = ORBIT_RADIUS * Math.sin(phi) * Math.cos(theta);

            camera.position.set(x, y, z);
            camera.lookAt(0, 0, 0); 

            // 3. Renderizar la Escena
            renderer.render(scene, camera);
        }

        /**
         * Muestra un mensaje temporal en la pantalla (simula un alert, but with UI).
         */
        function showMessage(text, duration, color) {
            let messageBox = document.getElementById('messageBox');
            if (!messageBox) {
                messageBox = document.createElement('div');
                messageBox.id = 'messageBox';
                // Cambiado de top-4 a bottom-20 (por encima de los controles flotantes)
                messageBox.className = 'fixed bottom-20 left-1/2 transform -translate-x-1/2 p-3 rounded-lg shadow-xl text-white font-bold transition-opacity duration-300 pointer-events-none opacity-0 z-20';
                document.body.appendChild(messageBox);
            }
            
            messageBox.style.backgroundColor = color ? '#' + color.getHexString() : '#10b981';
            messageBox.textContent = text;
            messageBox.style.opacity = '1';
            
            clearTimeout(messageBox.timer);
            messageBox.timer = setTimeout(() => {
                messageBox.style.opacity = '0';
            }, duration);
        }

        // =================================================================
        // LÓGICA DE TRIVIA (JEOPARDY)
        // =================================================================
        let currentScore = 0;
        let availableQuestions = {};
        let activeQuestion = null;

        const JEOPARDY_POINTS = [100, 200, 300, 400, 500];
        const JEOPARDY_CATEGORIES = {
            'PHYSICS': 'FÍSICA (Gravedad)',
            'AUDIO': 'COMPOSICIÓN',
            'VISUALS': 'DATOS DEL SISTEMA'
        };
        const PULSE_NAME_MAP = {
            'melodic': 'Melódico (Continua)',
            'percussive_bell': 'Tambor (Percusivo)',
            'pulse_bass': 'Bajo (Sub-Bass)',
            'glissando': 'Glissando (Barrido)',
            'filtered_noise': 'Ruido (Filtrado)'
        };
        
        // --- BASE DE DATOS DE PREGUNTAS SOBRE EL SISTEMA SOLAR ---
        const ASTRONOMY_QUESTIONS = {
            // CATEGORÍA: FÍSICA (Gravedad, Órbitas, Movimiento)
            'PHYSICS': [
                {
                    question: '¿Qué ley de Kepler describe que la órbita de un planeta es una elipse con el Sol en uno de sus focos?',
                    answer: 'Primera Ley',
                    options: ['Primera Ley', 'Segunda Ley', 'Tercera Ley', 'Ley de Gravitación Universal'],
                    points: 100
                },
                {
                    question: '¿Qué planeta tiene la gravedad superficial más fuerte en el Sistema Solar?',
                    answer: 'Júpiter',
                    options: ['Tierra', 'Júpiter', 'Saturno', 'Sol'],
                    points: 200
                },
                {
                    question: '¿Cuál es el planeta que rota más lentamente sobre su propio eje?',
                    answer: 'Venus',
                    options: ['Marte', 'Júpiter', 'Venus', 'Mercurio'],
                    points: 300
                },
                {
                    question: '¿Cuál es el planeta más caliente, a pesar de no ser el más cercano al Sol?',
                    answer: 'Venus',
                    options: ['Mercurio', 'Marte', 'Venus', 'Tierra'],
                    points: 400
                },
                {
                    question: 'La influencia gravitacional de Júpiter fue clave en la formación de, ¿qué cinturón de asteroides?',
                    answer: 'Cinturón de Kuiper',
                    options: ['Cinturón de Kuiper', 'Cinturón de Asteroides principal (entre Marte y Júpiter)', 'Nube de Oort', 'Cinturón de Van Allen'],
                    points: 500
                },
            ],

            // CATEGORÍA: COMPOSICIÓN (Atmósfera, Lunas, Materiales)
            'AUDIO': [ // Usando AUDIO como el nombre de la categoría en el código, pero se llama COMPOSICIÓN en el tablero
                {
                    question: '¿Qué planeta tiene la mayor cantidad de lunas confirmadas?',
                    answer: 'Saturno',
                    options: ['Júpiter', 'Urano', 'Saturno', 'Neptuno'],
                    points: 100
                },
                {
                    question: '¿Cuál es el principal componente de las atmósferas de Júpiter y Saturno?',
                    answer: 'Hidrógeno y Helio',
                    options: ['Nitrógeno y Oxígeno', 'Dióxido de Carbono', 'Hidrógeno y Helio', 'Metano y Amoníaco'],
                    points: 200
                },
                {
                    question: '¿Qué luna de Júpiter es conocida por su intensa actividad volcánica?',
                    answer: 'Ío',
                    options: ['Europa', 'Ganímedes', 'Calisto', 'Ío'],
                    points: 300
                },
                {
                    question: 'El núcleo de la Tierra está compuesto principalmente de...',
                    answer: 'Hierro y Níquel',
                    options: ['Silicato y Magnesio', 'Hierro y Níquel', 'Oro y Platino', 'Agua Congelada'],
                    points: 400
                },
                {
                    question: '¿Cuál es el nombre del planeta enano más grande conocido en el Cinturón de Kuiper?',
                    answer: 'Eris',
                    options: ['Haumea', 'Plutón', 'Ceres', 'Eris'],
                    points: 500
                },
            ],

            // CATEGORÍA: VISUALES (Tamaño, Anillos, Apariencia)
            'VISUALS': [ // Usando VISUALES como el nombre de la categoría en el código, pero se llama DATOS DEL SISTEMA en el tablero
                {
                    question: '¿Cuál de estos planetas no tiene anillos?',
                    answer: 'Marte',
                    options: ['Urano', 'Neptuno', 'Júpiter', 'Marte'],
                    points: 100
                },
                {
                    question: 'El Gran Punto Rojo es una tormenta persistente en la atmósfera de, ¿qué planeta?',
                    answer: 'Júpiter',
                    options: ['Marte', 'Júpiter', 'Saturno', 'Urano'],
                    points: 200
                },
                {
                    question: '¿Cuál es el planeta más grande del Sistema Solar?',
                    answer: 'Júpiter',
                    options: ['Saturno', 'Tierra', 'Júpiter', 'Urano'],
                    points: 300
                },
                {
                    question: '¿Qué planeta tiene un distintivo color azul verdoso debido al metano en su atmósfera?',
                    answer: 'Urano',
                    options: ['Neptuno', 'Urano', 'Tierra', 'Marte'],
                    points: 400
                },
                {
                    question: '¿Cómo se llama la luna de Saturno que es la única conocida por tener una atmósfera densa?',
                    answer: 'Titán',
                    options: ['Encélado', 'Rea', 'Titán', 'Jápeto'],
                    points: 500
                },
            ]
        };
        // --- FIN BASE DE DATOS DE PREGUNTAS ---

        /**
         * Inicializa las preguntas del tablero usando la base de datos de astronomía.
         */
        function initializeJeopardyQuestions() {
            availableQuestions = {};

            JEOPARDY_POINTS.forEach(points => {
                availableQuestions[points] = {};
                
                Object.keys(JEOPARDY_CATEGORIES).forEach(categoryKey => {
                    // Encontrar la pregunta que corresponde a la categoría y los puntos
                    const questionData = ASTRONOMY_QUESTIONS[categoryKey].find(q => q.points === points);

                    if (questionData) {
                        availableQuestions[points][categoryKey] = {
                            category: JEOPARDY_CATEGORIES[categoryKey],
                            points: points,
                            question: questionData.question,
                            answer: questionData.answer,
                            // Aseguramos que las opciones se mezclen
                            options: questionData.options.sort(() => 0.5 - Math.random()) 
                        };
                    }
                });
            });
        }


        /**
         * Muestra el tablero de Jeopardy.
         */
        function renderJeopardyBoard() {
            const boardContainer = document.getElementById('jeopardyBoard');
            const categories = Object.keys(JEOPARDY_CATEGORIES);
            
            // Ocultar la vista de pregunta individual
            document.getElementById('questionDisplay').classList.add('hidden');
            document.getElementById('questionDisplay').classList.remove('flex');
            
            // Mostrar el tablero
            boardContainer.classList.remove('hidden');

            // Limpiar las celdas anteriores (dejar los títulos de categoría)
            const cellsToRemove = boardContainer.querySelectorAll('.point-cell');
            cellsToRemove.forEach(cell => cell.remove());
            
            JEOPARDY_POINTS.forEach(points => {
                categories.forEach(categoryKey => {
                    const cell = document.createElement('button');
                    // Celdas de Puntos: Turquesa y Texto Blanco
                    cell.className = 'point-cell question-card bg-trivia-teal hover:bg-teal-600 text-3xl font-extrabold rounded-lg p-3 m-1 text-white';
                    cell.textContent = `$${points}`;
                    cell.dataset.category = categoryKey;
                    cell.dataset.points = points;
                    
                    // Comprobar si la pregunta ya fue respondida
                    if (availableQuestions[points] && availableQuestions[points][categoryKey] && availableQuestions[points][categoryKey].answered) {
                        cell.classList.add('answered', 'bg-gray-700');
                        cell.textContent = ''; // Vaciar la celda
                        cell.disabled = true;
                    } else {
                         cell.addEventListener('click', () => showQuestion(categoryKey, points));
                    }

                    boardContainer.appendChild(cell);
                });
            });

            document.getElementById('questionDisplay').classList.add('hidden');
            boardContainer.classList.remove('hidden');
        }

        /**
         * Muestra la pregunta seleccionada.
         */
        function showQuestion(categoryKey, points) {
            activeQuestion = availableQuestions[points][categoryKey];

            if (!activeQuestion) {
                 showMessage('Error: Pregunta no disponible.', 2000, new THREE.Color(0xef4444));
                 renderJeopardyBoard();
                 return;
            }
            
            // Si la pregunta ya fue respondida, no hacer nada (solo debería pasar si se manipula el DOM)
            if (activeQuestion.answered) {
                renderJeopardyBoard(); 
                return;
            }


            document.getElementById('jeopardyBoard').classList.add('hidden');
            
            const display = document.getElementById('questionDisplay');
            display.classList.remove('hidden');
            display.classList.add('flex');

            // Los elementos internos de la tarjeta de pregunta son negros contra el fondo blanco
            document.getElementById('questionCategory').textContent = activeQuestion.category;
            document.getElementById('questionValue').textContent = `VALOR: $${activeQuestion.points}`;
            document.getElementById('currentQuestionText').textContent = activeQuestion.question;
            document.getElementById('feedbackMessage').classList.add('hidden');
            document.getElementById('backToBoardButton').classList.add('hidden');
            
            const optionsContainer = document.getElementById('optionsContainer');
            optionsContainer.innerHTML = activeQuestion.options.map((option, index) => `
                <button data-answer="${option}" 
                        data-category="${categoryKey}" 
                        data-points="${points}"
                        class="trivia-option-button w-full text-left p-3 bg-gray-300 hover:bg-yellow-400 text-gray-900 rounded-md transition duration-150 text-base">
                    ${String.fromCharCode(65 + index)}. ${option}
                </button>
            `).join('');

            // Enlazar evento de click a los botones de opción
            document.querySelectorAll('.trivia-option-button').forEach(button => {
                button.addEventListener('click', handleAnswer);
            });
        }


        /**
         * Maneja la respuesta del usuario.
         */
        function handleAnswer(event) {
            const button = event.target;
            const userAnswer = button.dataset.answer;
            const categoryKey = button.dataset.category;
            const points = parseInt(button.dataset.points);
            
            const question = availableQuestions[points][categoryKey];
            const correct = question.answer;

            // Deshabilitar todos los botones de opción
            document.querySelectorAll('.trivia-option-button').forEach(btn => {
                btn.disabled = true;
                btn.classList.remove('hover:bg-yellow-600');
                // Asegurar que el texto se mantenga legible en los botones de opción
                btn.classList.remove('text-gray-900'); 
                btn.classList.add('text-white');
                
                if (btn.dataset.answer === correct) {
                    btn.classList.add('bg-green-600'); // Respuesta correcta
                } else if (btn.dataset.answer === userAnswer) {
                    btn.classList.add('bg-red-600'); // Respuesta incorrecta elegida
                } else {
                    btn.classList.add('bg-gray-500'); // Opciones no seleccionadas/incorrectas
                }
            });

            const feedback = document.getElementById('feedbackMessage');
            feedback.classList.remove('hidden', 'text-green-400', 'text-red-400');
            
            // Actualizar estado de la pregunta y puntuación
            if (userAnswer === correct) {
                currentScore += points;
                feedback.textContent = `¡CORRECTO! Ganaste $${points} puntos.`;
                feedback.classList.add('text-green-600'); // Verde oscuro sobre fondo blanco
            } else {
                currentScore -= points;
                feedback.textContent = `INCORRECTO. Perdiste $${points} puntos. La respuesta era: ${correct}`;
                feedback.classList.add('text-red-600'); // Rojo oscuro sobre fondo blanco
            }

            // Marcar como respondida y actualizar el marcador
            question.answered = true;
            document.getElementById('currentScore').textContent = currentScore;
            
            document.getElementById('backToBoardButton').classList.remove('hidden');
        }

        /**
         * Función auxiliar para generar opciones de respuesta, asegurando que la correcta esté incluida.
         */
        function generateOptions(correctAnswer, allPossibleOptions, minCount = 3) {
            let options = [correctAnswer];
            let pool = allPossibleOptions.filter(opt => opt !== correctAnswer);
            
            // Asegurar que haya al menos dos opciones falsas de la piscina
            while (options.length < minCount && pool.length > 0) {
                const randomIndex = Math.floor(Math.random() * pool.length);
                options.push(pool.splice(randomIndex, 1)[0]);
            }
            // Si la piscina no fue suficiente, añadir opciones genéricas
             while (options.length < minCount) {
                options.push(`Opción Falsa ${options.length}`);
            }

            // Si hay más de 4 opciones, recortar a 4 (para el layout de 2x2)
            if (options.length > 4) {
                options = options.slice(0, 4);
            }
            
            // Mezclar las opciones
            return options.sort(() => 0.5 - Math.random());
        }

        /**
         * Inicia el modo trivia.
         */
        function startJeopardy() {
            // Ya no requerimos planetas creados para preguntas del Sistema Solar.
            /*
            if (planets.length === 0) {
                showMessage('Crea al menos un planeta para iniciar la Trivia.', 3000, new THREE.Color(0xfacc15));
                return;
            }
            */

            // Pausar la simulación al entrar a la Trivia
            if (!isPaused) {
                togglePause();
            }

            // Mostrar el overlay y ocultar controles
            document.getElementById('jeopardyOverlay').classList.remove('hidden');
            document.getElementById('controls').style.opacity = '0';
            document.getElementById('controls').style.pointerEvents = 'none';

            // Resetear estado de trivia
            currentScore = 0;
            document.getElementById('currentScore').textContent = 0;
            
            initializeJeopardyQuestions(); // Cargar las preguntas de astronomía
            renderJeopardyBoard();
        }
        
        /**
         * Regresa a la simulación desde el Jeopardy.
         */
        function resumeSimulation() {
            document.getElementById('jeopardyOverlay').classList.add('hidden');
            
            // Mostrar controles
            document.getElementById('controls').style.opacity = '1';
            document.getElementById('controls').style.pointerEvents = 'auto';

            // Reanudar la simulación (si el botón de Pausa dice 'Reanudar Simulación')
            if (document.getElementById('pauseButton').textContent === 'Reanudar Simulación') {
                togglePause();
            }
        }


        // =================================================================
        // INICIO
        // =================================================================

        document.getElementById('startButton').addEventListener('click', () => {
            startAudioContext(); 
            
            const overlay = document.getElementById('overlay');
            overlay.style.opacity = '0';
            
            setTimeout(() => {
                overlay.style.pointerEvents = 'none';
            }, 500); 
            
            const controls = document.getElementById('controls');
            controls.style.opacity = '1';
            controls.style.pointerEvents = 'auto';

            init();
            animate();

            // CORRECCIÓN CRÍTICA: Enlazar los botones de control aquí,
            // después de que init() se ha llamado y los botones existen en el DOM
            document.getElementById('pauseButton').addEventListener('click', togglePause);
            document.getElementById('clearButton').addEventListener('click', clearSimulation);
            document.getElementById('triviaButton').addEventListener('click', startJeopardy); // Nuevo botón
            document.getElementById('resumeButton').addEventListener('click', resumeSimulation); // Botón de regreso de trivia
            document.getElementById('backToBoardButton').addEventListener('click', renderJeopardyBoard); // Botón para volver al tablero
            
            showMessage('¡Simulación Iniciada! Crea sistemas binarios y observa la gravedad.', 3500, new THREE.Color(0x22c55e));
        });

    </script>
</body>
</html>



