<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Armonía de las Esferas</title>
    <!-- Carga de Tailwind CSS para estilos modernos y responsivos -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configuración de Tailwind para incluir colores personalizados
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'space-dark': '#0d0d1a',
                        'space-blue': '#1a202c',
                        // Se define el naranja de la marca para usar en hover/focus
                        'brand-orange': '#f75b0f', 
                    }
                }
            }
        }
    </script>
    <!-- Carga de Three.js para la renderización 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Carga de Tone.js para la generación de audio -->
    <script src="https://unpkg.com/tone@14.7.58/build/Tone.js"></script>
    <style>
        /* Estilos personalizados para el cuerpo y el canvas */
        body {
            margin: 0;
            overflow: hidden; /* Evita barras de desplazamiento */
            font-family: 'Inter', sans-serif;
            background-color: #0d0d1a; /* Fondo oscuro espacial */
        }
        canvas {
            display: block;
            touch-action: none; /* Previene el comportamiento nativo del navegador al arrastrar */
        }
        /* Intenta aumentar el grosor de línea si el navegador lo permite */
        canvas.webgl-canvas {
            stroke-width: 2px;
        }
    </style>
</head>
<body>

    <!-- Contenedor del Canvas y Overlay de Instrucciones -->
    <div id="container"></div>

    <!-- Overlay de Inicio - AHORA CUBRE TODA TODA LA PANTALLA CON EL COLOR NARANJA -->
    <div id="overlay" style="background-color: #f75b0f;" class="fixed inset-0 flex flex-col items-center justify-center p-4 text-white transition-opacity duration-500 ease-in-out z-10">
        
        <div class="flex flex-col items-center text-center p-4">
            
            <!-- Título principal en color blanco, más grande y prominente -->
            <h1 class="text-6xl sm:text-7xl font-extrabold mb-12 text-white uppercase tracking-wider">
                Armonía de las Esferas
            </h1>
            
            <!-- Botón de inicio en blanco con texto naranja, más grande -->
            <button id="startButton" class="px-10 py-5 bg-white hover:bg-gray-200 text-brand-orange font-extrabold text-xl rounded-xl shadow-2xl transition transform hover:scale-105">
                ¡Empezar Simulación!
            </button>
        </div>
    </div>
    
    <!-- Controles Flotantes -->
    <div id="controls" class="fixed inset-x-0 bottom-4 flex flex-col items-center space-y-3 z-20 opacity-0 transition-opacity duration-500 pointer-events-none sm:flex-row sm:justify-between sm:bottom-auto sm:top-4 sm:space-y-0 sm:px-6">
        
        <!-- Botón Pausar/Reanudar -->
        <div class="sm:order-1 sm:w-auto">
            <button id="pauseButton" class="px-5 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50">
                Pausar Simulación
            </button>
        </div>
        
        <!-- Selector de SONIDO RÍTMICO -->
        <div class="w-full sm:w-auto sm:order-2">
            <label for="rhythmSoundSelect" class="block text-sm font-medium text-white mb-1">Pulso Planeta:</label>
            <select id="rhythmSoundSelect" class="w-full sm:w-36 p-2 bg-gray-800 text-white rounded-lg border border-gray-700 focus:ring-brand-orange focus:border-brand-orange transition duration-150">
                <option value="melodic">Melódico (Continua)</option>
                <option value="percussive_bell">Tambor (Percusivo)</option>
                <option value="pulse_bass">Bajo (Sub-Bass)</option>
                <option value="glissando">Glissando (Barrido)</option>
                <option value="filtered_noise">Ruido (Filtrado)</option>
            </select>
        </div>

        <!-- Menú de Selección de Entidad -->
        <div class="w-full sm:w-auto sm:order-3">
            <label for="entitySelect" class="block text-sm font-medium text-white mb-1">Crear:</label>
            <select id="entitySelect" class="w-full sm:w-36 p-2 bg-gray-800 text-white rounded-lg border border-gray-700 focus:ring-brand-orange focus:border-brand-orange transition duration-150">
                <option value="planet">Planeta</option>
                <option value="sun">Sol</option>
            </select>
        </div>

        <!-- Botón Reiniciar Simulación (Bottom-Center) -->
        <div class="sm:order-4 sm:w-auto">
            <button id="clearButton" style="background-color: #f75b0f;" class="px-5 py-3 hover:bg-orange-700 text-white font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-orange-500 focus:ring-opacity-50">
                Reiniciar Simulación
            </button>
        </div>
    </div>

    <script>
        // Configuración global de Three.js
        let scene, camera, renderer;
        let ambientLight;
        let starField; // Variable para el campo de estrellas
        
        // --- ARRAYS GLOBALES PARA MÚLTIPLES OBJETOS ---
        const suns = []; 
        const planets = [];
        
        // =================================================================
        // CONSTANTES DE FÍSICA Y TIEMPO
        // =================================================================
        const GRAVITATIONAL_CONSTANT = 1.0; 
        const SUN_MASS = 1000.0; 
        const PLANET_MASS = 1.0; 
        const TIME_STEP = 0.05; 
        const MIN_DISTANCE = 25;
        const MAX_DISTANCE = 150;
        const COLLISION_DISTANCE = 18; 
        const MAX_SUN_DISTANCE = 100; 
        
        // Aumentamos la longitud del rastro a 100 puntos (antes 50)
        const TRAIL_LENGTH = 100; 
        
        // NUEVA VARIABLE DE ESTADO
        let isPaused = false;
        
        // Objeto para ayudar en la conversión de coordenadas 2D a 3D
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        
        // Vectores temporales para evitar reasignaciones constantes y ahorrar memoria/rendimiento
        const tempVector = new THREE.Vector3();
        
        // =================================================================
        // VARIABLES DE CONTROL DE CÁMARA (MANUAL)
        // =================================================================
        let isDragging = false; 
        let isPointerActive = false;
        let pointerStart = { x: 0, y: 0 };
        let previousPointerPosition = { x: 0, y: 0 };
        const ORBIT_RADIUS = 150; 
        
        let theta = 0; 
        let phi = Math.PI / 2;
        
        const DAMPING_FACTOR = 0.9; 
        const ROTATION_MULTIPLIER = 0.005;
        let velocityX = 0;
        let velocityY = 0;
        
        const DRAG_THRESHOLD = 5;

        // =================================================================
        // CONFIGURACIÓN DE AUDIO (TONE.JS)
        // =================================================================
        let isAudioContextStarted = false;

        // Rango de Frecuencias (en Hz) para el mapeo dinámico
        const MIN_FREQ = 65.41; // C2 (Nota más grave)
        const MAX_FREQ = 261.63; // C4 (Nota más aguda, pero aún suave)
        
        // Variables para el control de ritmo
        let audioClock = 0;
        const RHYTHM_STEP = 0.5; // El tiempo que debe pasar en el audio para actualizar el reloj
        const RHYTHM_MULTIPLIER = 0.02; // Velocidad del reloj interno
        
        // Sintetizadores globales para los pulsos (que no cambian de estado)
        let basicPulseSynth; 
        let drumSynth; // Sintetizador de Percusión Dinámica (Tambor)
        let subBassSynth; // Sintetizador de Bajo (Sub-Bass)
        let glissandoSynth; // Sintetizador de Glissando (Barrido de Tono)
        let filteredNoiseSynth; // Nuevo: Sintetizador de Ruido Filtrado

        // Se inicializa una reverberación para dar un ambiente espacial a todos los sonidos
        const reverb = new Tone.Reverb({
            decay: 2.5,
            preDelay: 0.02,
            wet: 0.3 
        }).toDestination();


        /**
         * Inicializa los sintetizadores de pulso rítmico.
         */
        function setupAudio() {
             // 1. Pulso Básico (Sine wave bajo y corto - Ritmo fijo)
             const basicConfig = {
                oscillator: { type: "sine" }, 
                envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 },
                volume: -15 
            };
            basicPulseSynth = new Tone.Synth(basicConfig).toDestination();
            
            // 2. Tambor (Percusivo) - Usando FMSynth para un sonido percusivo más suave y armónico
             drumSynth = new Tone.FMSynth({
                oscillator: { type: "sine" },
                envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 },
                modulation: { type: "triangle" }, // Modulación para añadir riqueza armónica
                modulationEnvelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 },
                modulationIndex: 1, 
                harmonicity: 1.5,
                volume: -5 // Aumento de volumen de -8 a -5
            }).connect(reverb);
            
            // 3. Bajo (Sub-Bass) - Usando onda triangular para un bajo suave y profundo
            subBassSynth = new Tone.Synth({
                oscillator: { type: "triangle" }, 
                envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 },
                volume: -10 // Aumentado de -15 a -10 dB
            }).toDestination();

            // 4. Glissando (Barrido de Tono) - Usando Synth con onda de sierra para un barrido rico
            glissandoSynth = new Tone.Synth({
                oscillator: { type: "sawtooth" }, // Onda de sierra para un timbre rico
                envelope: { attack: 0.01, decay: 0.8, sustain: 0.0, release: 0.1 }, // Rápido ataque y decaimiento
                volume: -18 // Volumen reducido de -10 a -18 dB
            }).toDestination();

            // 5. Ruido Filtrado (Textura)
            filteredNoiseSynth = new Tone.NoiseSynth({
                noise: { type: "brown" }, // Ruido marrón (más grave y suave)
                envelope: { attack: 0.01, decay: 0.2, sustain: 0.0, release: 0.2 },
                filter: { type: "bandpass", frequency: 1000, Q: 1.5 }, // Filtro de paso de banda
                volume: -15
            }).toDestination();
        }


        /**
         * Crea el sintetizador único de tono continuo (onda sinusoidal) y el panner.
         * ESTE ES EL SINTETIZADOR DE MELODÍA CONTINUA.
         * @returns {object} Un objeto con la instancia del sintetizador y el panner.
         */
        function createSynth() {
            // Configuración para un sonido de onda sinusoidal (sine)
            const config = {
                oscillator: { type: "sine" }, // Onda Sinusoidal
                envelope: { 
                    attack: 0.05, 
                    decay: 0.5, 
                    sustain: 1.0, // Sostenido alto para sonido continuo
                    release: 1.5 // El release largo
                },
                volume: -15 // Volumen base ligeramente más bajo
            };
            
            const panner = new Tone.Panner().connect(reverb);
            const synthInstance = new Tone.Synth(config).connect(panner);
            return { synth: synthInstance, panner: panner };
        }


        /**
         * Inicializa el AudioContext de Tone.js después del primer toque del usuario.
         */
        function startAudioContext() {
            if (!isAudioContextStarted) {
                Tone.start(); 
                isAudioContextStarted = true;
                setupAudio(); // Inicializa los synths de pulso
            }
        }

        // =================================================================
        // FUNCIONES DE FÍSICA
        // =================================================================

        /**
         * Calcula la aceleración gravitacional neta sobre el planeta causada por todos los soles.
         * F = G * M1 * M2 / r^2
         * A = F / M2 = G * M1 / r^2
         * @param {object} planet El objeto planeta con posición, masa y aceleración.
         */
        function calculateGravity(planet) {
            const netAcceleration = new THREE.Vector3(0, 0, 0);

            suns.forEach(sun => {
                // Vector que apunta del planeta al sol
                // Usamos sun.mesh.position porque es la instancia THREE.Vector3 del mesh.
                const direction = tempVector.copy(sun.mesh.position).sub(planet.mesh.position);
                const distanceSq = direction.lengthSq();

                // Evitar división por cero o fuerzas infinitas en colisión cercana
                if (distanceSq < 1) { 
                    return;
                }
                
                const distance = Math.sqrt(distanceSq);

                // Fuerza gravitacional: A = (G * M_sol / r^2) * (vector unitario)
                const magnitude = (GRAVITATIONAL_CONSTANT * SUN_MASS) / distanceSq;

                // Asegurar que la fuerza no sea demasiado grande a corta distancia
                const maxMagnitude = 5.0; // Límite de aceleración para estabilidad
                const finalMagnitude = Math.min(magnitude, maxMagnitude);

                direction.normalize().multiplyScalar(finalMagnitude);
                
                netAcceleration.add(direction);
            });

            planet.acceleration = netAcceleration;
        }

        /**
         * Aplica la integración de Euler para actualizar la velocidad y posición.
         * @param {object} planet El objeto planeta.
         * @param {number} deltaTime El paso de tiempo.
         */
        function updatePhysics(planet, deltaTime) {
            // Velocidad = Velocidad + Aceleración * dt
            planet.velocity.add(planet.acceleration.clone().multiplyScalar(deltaTime));
            
            // Posición = Posición + Velocidad * dt
            planet.mesh.position.add(planet.velocity.clone().multiplyScalar(deltaTime));
        }

        /**
         * Encuentra el Sol más cercano al punto de click.
         * @param {THREE.Vector3} clickPosition Posición 3D del click.
         * @returns {object} El objeto Sol más cercano.
         */
        function findNearestSun(clickPosition) {
            let minDistanceSq = Infinity;
            let nearestSun = null;
            
            suns.forEach(sun => {
                // Usamos subVectors y lengthSq para calcular la distancia.
                const diffVector = new THREE.Vector3().subVectors(sun.mesh.position, clickPosition);
                const distanceSq = diffVector.lengthSq(); 
                
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    nearestSun = sun;
                }
            });

            return nearestSun;
        }

        // =================================================================
        // UTILIDADES
        // =================================================================

        /**
         * Inicializa la escena, cámara, renderizador y luces.
         */
        function init() {
            // 1. Configuración de la Escena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0d0d1a, 0.003); 

            // 2. Configuración de la Cámara (perspectiva para 3D)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, ORBIT_RADIUS); // Posición inicial
            
            // 3. Configuración del Renderizador (WebGL)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
            // Añadir una clase para apuntar con CSS si queremos aumentar el grosor de línea
            renderer.domElement.classList.add('webgl-canvas'); 
            document.getElementById('container').appendChild(renderer.domElement);
            
            // 4. Configuración de la Iluminación
            ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
            scene.add(ambientLight);

            // 5. Crear el Sol Central Inicial y el Fondo de Estrellas
            createInitialSun(); 
            createStarField(); 
            
            // 6. Manejadores de Eventos
            window.addEventListener('resize', onWindowResize, false);
            setupPointerControls(renderer.domElement);
            
            // MOVEMOS EL EVENTO DE PAUSA/REINICIAR AL START BUTTON LISTENER
        }

        /**
         * Crea el primer Sol al iniciar la simulación.
         */
        function createInitialSun() {
            const center = new THREE.Vector3(0, 0, 0);
            createSunAtPosition(center);
        }

        /**
         * Crea un objeto Sol y lo añade a la escena y al array de Soles.
         * @param {THREE.Vector3} position Posición del nuevo sol.
         */
        function createSunAtPosition(position) {
            const sunRadius = 12;
            const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32); 
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                emissive: 0xff8800 
            }); 
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.copy(position);
            scene.add(sunMesh);
            
            const flareTexture = generateRadialTexture(); 

            const lightSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: flareTexture,
                color: 0xff8800, 
                blending: THREE.AdditiveBlending, 
                transparent: true,
                opacity: 0.7 
            }));
            lightSprite.scale.set(50, 50, 1.0); 
            sunMesh.add(lightSprite);

            // Cada sol necesita una luz para iluminar a los planetas a su alrededor
            const sunLight = new THREE.PointLight(0xffffff, 3.0, 0, 0); 
            sunLight.position.copy(position);
            scene.add(sunLight);

            // Se almacena el mesh para acceder a su posición Vector3
            suns.push({ mesh: sunMesh, light: sunLight, mass: SUN_MASS });
        }


        /**
         * Crea un campo de estrellas aleatorias para el fondo.
         */
        function createStarField() {
            const starCount = 1500;
            const starGeometry = new THREE.BufferGeometry();
            const positions = [];
            
            const radius = 500; 

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(radius * 2);
                const y = THREE.MathUtils.randFloatSpread(radius * 2);
                const z = THREE.MathUtils.randFloatSpread(radius * 2);

                positions.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1, 
                sizeAttenuation: true 
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }
        
        /**
         * Genera una textura circular suave con degradado para simular un brillo (flare).
         */
        function generateRadialTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');

            const gradient = context.createRadialGradient(
                size / 2, size / 2, 0, 
                size / 2, size / 2, size / 2 
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)'); 
            gradient.addColorStop(1, 'rgba(255,255,255,0)'); 

            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);

            return new THREE.CanvasTexture(canvas);
        }

        /**
         * Configura los eventos de mouse y touch para el control de la cámara.
         */
        function setupPointerControls(element) {
            element.addEventListener('pointerdown', onPointerDown, false);
            element.addEventListener('pointermove', onPointerMove, false);
            element.addEventListener('pointerup', onPointerUp, false);
            element.addEventListener('pointerleave', onPointerUp, false);
        }

        /**
         * Evento al pulsar (clic o tocar).
         */
        function onPointerDown(event) {
            if (event.buttons === 1 || event.pointerType === 'touch') { 
                isPointerActive = true; 
                isDragging = false; 
                
                pointerStart.x = event.clientX;
                pointerStart.y = event.clientY;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
                velocityX = 0;
                velocityY = 0;
            }
        }

        /**
         * Evento al mover el puntero (arrastrar).
         */
        function onPointerMove(event) {
            
            if (!isPointerActive) return; 

            if (!isDragging) {
                const deltaMovementX = event.clientX - pointerStart.x;
                const deltaMovementY = event.clientY - pointerStart.y;
                const distance = Math.sqrt(deltaMovementX * deltaMovementX + deltaMovementY * deltaMovementY); 
                
                if (distance > DRAG_THRESHOLD) {
                    isDragging = true; 
                }
            }

            if (isDragging) { 
                const deltaX = event.clientX - previousPointerPosition.x;
                const deltaY = event.clientY - previousPointerPosition.y;

                theta += deltaX * ROTATION_MULTIPLIER;
                phi -= deltaY * ROTATION_MULTIPLIER;
                
                velocityX = deltaX * ROTATION_MULTIPLIER * 0.5;
                velocityY = deltaY * ROTATION_MULTIPLIER * 0.5;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
            }
        }

        /**
         * Evento al soltar (dejar de arrastrar o crear entidad).
         */
        function onPointerUp(event) {
            if (isPointerActive && !isDragging) { 
                const entitySelect = document.getElementById('entitySelect');
                const selectedEntity = entitySelect ? entitySelect.value : 'planet';
                
                if (selectedEntity === 'planet') {
                    createPlanet(event);
                } else if (selectedEntity === 'sun') {
                    createSunOnClick(event);
                }
            }
            
            isDragging = false; 
            isPointerActive = false; 
        }

        /**
         * Intenta crear un Sol en la posición del click/toque.
         */
        function createSunOnClick(event) {
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);

            // Limitar la distancia del Sol para evitar que aparezca muy lejos
            if (intersection.length() > MAX_SUN_DISTANCE) {
                intersection.normalize().multiplyScalar(MAX_SUN_DISTANCE);
                showMessage('Sol colocado en el límite de la zona central.', 2000, new THREE.Color(0xfacc15));
            }


            createSunAtPosition(intersection);
            showMessage('¡Nuevo Sol Creado! Ahora afecta la gravedad.', 2000, new THREE.Color(0xfacc15));
        }

        /**
         * Crea un nuevo planeta.
         * @param {PointerEvent} event El evento de puntero (contiene clientX/Y).
         */
        function createPlanet(event) {
            startAudioContext(); 

            if (suns.length === 0) {
                showMessage('No hay soles para orbitar. ¡Crea un Sol primero!', 3000, new THREE.Color(0xef4444));
                return;
            }

            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);
            const initialPosition = intersection.clone();

            // --- 1. ENCONTRAR EL SOL MÁS CERCANO PARA INICIALIZAR LA ÓRBITA ---
            const nearestSun = findNearestSun(initialPosition);
            
            // Usamos la posición del mesh del sol para la física
            const relativePosition = initialPosition.clone().sub(nearestSun.mesh.position);
            const distance = relativePosition.length();

            if (distance < COLLISION_DISTANCE) {
                showMessage('Demasiado cerca del Sol. Intenta más lejos.', 3000, new THREE.Color(0xfacc15));
                return;
            }

            // 2. CÁLCULO DE VELOCIDAD INICIAL (para órbita circular aproximada alrededor del Sol más cercano)
            
            // Magnitud de la velocidad orbital: v = sqrt(G*M/r)
            const orbitVelocityMag = Math.sqrt((GRAVITATIONAL_CONSTANT * SUN_MASS) / distance);
            
            // Dirección de la velocidad: perpendicular al vector posición (para iniciar la órbita)
            const positionUnit = relativePosition.clone().normalize();
            
            // Usa el producto cruz con el vector 'up' (Y=1) para obtener una velocidad tangencial
            let initialVelocity = new THREE.Vector3().crossVectors(positionUnit, new THREE.Vector3(0, 1, 0));
            
            // Si el producto cruz es casi cero (el planeta está en Y, que no debería pasar aquí)
            if (initialVelocity.lengthSq() < 0.001) {
                initialVelocity.set(1, 0, 0); 
            }
            
            // Velocidad inicial más ajustada (0.95 a 1.05) para asegurar una órbita estable
            initialVelocity.normalize().multiplyScalar(orbitVelocityMag * THREE.MathUtils.randFloat(0.95, 1.05));

            // Añadir una pequeña componente Y para dar una inclinación 3D inicial
            initialVelocity.y = THREE.MathUtils.randFloatSpread(orbitVelocityMag * 0.1); 

            // 3. GENERAR EL RESTO DE PROPIEDADES
            const radius = THREE.MathUtils.randFloat(1, 4); 
            
            const baseColor = new THREE.Color(Math.random(), Math.random(), Math.random());
            const hsl = {};
            baseColor.getHSL(hsl);
            hsl.l = THREE.MathUtils.randFloat(0.7, 0.9);
            hsl.s = THREE.MathUtils.randFloat(0.4, 0.8); 
            const brightColor = new THREE.Color().setHSL(hsl.h, hsl.s, hsl.l);


            // 4. Configuración de AUDIO
            const { synth, panner } = createSynth(); // Usamos panner
            
            // Lógica de nota inicial (solo para referencia, la frecuencia será dinámica)
            const distanceRange = MAX_DISTANCE - MIN_DISTANCE;
            const distanceRatio = (distance - MIN_DISTANCE) / distanceRange;
            const initialFrequency = THREE.MathUtils.mapLinear(distanceRatio, 0, 1, MAX_FREQ, MIN_FREQ); // Inversa: Cerca = Agudo, Lejos = Grave

            
            // --- NUEVAS VARIABLES DE RITMO Y SONIDO ---
            const rhythmOptions = [4, 8, 16, 32]; // Opciones rítmicas (por ejemplo, 1/4, 1/8, 1/16, etc.)
            const rhythm = rhythmOptions[Math.floor(Math.random() * rhythmOptions.length)]; 
            const baseVolume = THREE.MathUtils.randFloat(-10, -5); // -10dB a -5dB
            
            
            // Obtener el tipo de pulso seleccionado en el menú
            const rhythmSoundSelect = document.getElementById('rhythmSoundSelect');
            const pulseType = rhythmSoundSelect ? rhythmSoundSelect.value : 'melodic';
            
            // CONTROL DE MELODÍA CONTINUA
            if (pulseType !== 'melodic') {
                synth.volume.value = -100; // Silencia la melodía si es un modo rítmico
            } else {
                synth.volume.value = baseVolume; // Establece el volumen base para la melodía continua
            }


            // 5. Malla y Rastro (similar al código anterior)
            const planetGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const planetMaterial = new THREE.MeshLambertMaterial({ 
                color: brightColor, 
                emissive: brightColor.clone().multiplyScalar(0.1) 
            });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
            planetMesh.position.copy(initialPosition);

            const orbitPositions = new Float32Array(TRAIL_LENGTH * 3); 
            const drawingPositions = new Float32Array(TRAIL_LENGTH * 3);
            
            // Creación del Array de Colores (RGBA: 4 componentes por punto)
            const trailColors = new Float32Array(TRAIL_LENGTH * 4); 

            const trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(drawingPositions, 3)); 
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 4)); // Añadir atributo de color/opacidad
            
            const trailMaterial = new THREE.LineBasicMaterial({
                color: brightColor, 
                transparent: true,
                opacity: 1.0,
                vertexColors: true // Usar colores definidos por el vértice
            });
            const orbitTrail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(orbitTrail);

            // 6. Crear Objeto para el planeta (PROPIEDADES DE FÍSICA Y AUDIO)
            const planetObject = {
                mesh: planetMesh,
                trail: orbitTrail,
                orbitPositions: orbitPositions, 
                trailColors: trailColors, // Almacenar el array de colores
                planetColor: brightColor, // Color base del planeta
                trailIndex: 0,
                trailLength: TRAIL_LENGTH,
                trailCount: 0,
                // PROPIEDADES DE FÍSICA
                mass: PLANET_MASS,
                velocity: initialVelocity, // Vector3
                acceleration: new THREE.Vector3(0, 0, 0), // Vector3
                // PROPIEDADES DE AUDIO
                synth: synth,
                panner: panner, // Nuevo panner
                rhythm: rhythm, // Nuevo ritmo
                rhythmCounter: 0, // Contador interno para el ritmo
                pulseType: pulseType, // Tipo de pulso (melodic, percussive_bell, pulse_bass, glissando, filtered_noise)
                initialFrequency: initialFrequency, 
                isPlaying: false, 
                lastPulseTime: Date.now(), // Nuevo: tiempo del último golpe para ritmo dinámico
            };

            scene.add(planetMesh);
            planets.push(planetObject);
            
            // INICIAMOS EL SONIDO AL CREAR EL PLANETA
            planetObject.synth.triggerAttack(initialFrequency); // Iniciamos el ataque con la frecuencia inicial
            planetObject.isPlaying = true;

            showMessage(`¡Planeta Creado con Pulso ${pulseType}!`, 1500, brightColor);
        }

        /**
         * Alterna el estado de pausa de la simulación y la música.
         */
        function togglePause() {
            isPaused = !isPaused;
            const button = document.getElementById('pauseButton');
            
            if (isPaused) {
                button.textContent = 'Reanudar Simulación';
                button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                button.classList.add('bg-green-600', 'hover:bg-green-700');
                Tone.Master.mute = true;
                showMessage('Simulación PAUSADA.', 1500, new THREE.Color(0xfb923c));
            } else {
                button.textContent = 'Pausar Simulación';
                button.classList.remove('bg-green-600', 'hover:bg-green-700');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700');
                Tone.Master.mute = false;
                showMessage('Simulación REANUDADA.', 1500, new THREE.Color(0x22c55e));
            }
        }

        /**
         * Elimina todos los planetas, soles, sus rastros y sus sintetizadores.
         */
        function clearSimulation() {
            const initialSuns = suns.length;
            
            if (isPaused) {
                togglePause(); // Asegura reanudar si estaba pausado
            }
            
            // Detener el audio de todos los planetas antes de eliminarlos
            planets.forEach(planet => {
                if (planet.synth && planet.isPlaying) {
                    planet.synth.triggerRelease();
                }
            });

            // Limpieza de Planetas
            planets.forEach(planet => {
                if (planet.synth) planet.synth.dispose();
                scene.remove(planet.mesh);
                scene.remove(planet.trail);
            });
            planets.length = 0;

            // Limpieza de Soles
            suns.forEach(sun => {
                scene.remove(sun.mesh);
                scene.remove(sun.light);
            });
            suns.length = 0;
            
            // Vuelve a crear el sol inicial
            if (initialSuns === 0) {
                 createInitialSun(); 
            }
            
            audioClock = 0; // Reiniciar el reloj de audio

            showMessage('Simulación Reiniciada. ¡Crea nuevos sistemas!', 2500, new THREE.Color(0xef4444));
        }

        /**
         * Maneja el redimensionamiento de la ventana para mantener la vista correcta.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * Bucle principal de animación (game loop).
         */
        function animate() {
            requestAnimationFrame(animate);
            
            // 0. Rotación sutil del campo de estrellas
            if (starField) {
                starField.rotation.y += 0.00005; 
            }

            // 1. Mover Planetas y Actualizar Rastros y Audio (SOLO si NO está pausado)
            if (!isPaused) {
                // Actualizar el reloj de audio global (SOLO usado por el pulso 'basic')
                audioClock += RHYTHM_MULTIPLIER;
                if (audioClock >= RHYTHM_STEP * 32) { // 32 es el múltiplo más grande de los ritmos
                    audioClock = 0;
                }

                const currentTime = Date.now(); // Tiempo actual para el pulso dinámico

                for (let i = planets.length - 1; i >= 0; i--) {
                    const planet = planets[i];

                    // a. Calcular fuerzas y actualizar física
                    calculateGravity(planet);
                    updatePhysics(planet, TIME_STEP);
                    
                    // b. Detección de colisión (Ya no elimina) / expulsión (SOLO ELIMINA POR EXPULSIÓN)
                    if (planet.mesh.position.length() > 300) {
                        // Expulsión: Eliminar planeta
                        if (planet.synth) {
                            planet.synth.triggerRelease(); // Suelta la nota
                            planet.synth.dispose();
                        }
                        scene.remove(planet.mesh);
                        scene.remove(planet.trail);
                        planets.splice(i, 1);
                        showMessage('¡Planeta Escapado! Limpiado.', 1000, new THREE.Color(0xff4444));
                        continue; // Pasa al siguiente planeta
                    }


                    // c. LÓGICA DE AUDIO DINÁMICO Y RÍTMICO
                    
                    const nearestSun = findNearestSun(planet.mesh.position);
                    
                    if (nearestSun) {
                        const relativePosition = tempVector.copy(planet.mesh.position).sub(nearestSun.mesh.position);
                        const distance = relativePosition.length();
                        
                        // --- Mapeo de Frecuencia (PITCH/TONO) ---
                        const distanceClamped = THREE.MathUtils.clamp(distance, MIN_DISTANCE, MAX_DISTANCE);
                        const distanceRatio = THREE.MathUtils.mapLinear(distanceClamped, MIN_DISTANCE, MAX_DISTANCE, 0, 1);
                        const currentFrequency = THREE.MathUtils.mapLinear(distanceRatio, 0, 1, MAX_FREQ, MIN_FREQ);
                        
                        // Si el planeta no está silenciado, modula la frecuencia
                        if (planet.synth.volume.value > -99) {
                            planet.synth.frequency.rampTo(currentFrequency, 0.05);
                        }

                        // --- Mapeo de Panoramización (PANNING) ---
                        const panValue = THREE.MathUtils.clamp(relativePosition.x / MAX_DISTANCE, -1, 1);
                        planet.panner.pan.rampTo(panValue, 0.1); 


                        // --- Lógica Rítmica (PULSO) ---
                        
                        const rhythmUnit = RHYTHM_STEP * planet.rhythm;
                        const isTriggerTime = audioClock % rhythmUnit < RHYTHM_MULTIPLIER;
                        
                        if (planet.pulseType === 'melodic') {
                            // RITMO FIJO (Pulso de fondo para la melodía continua)
                            // AÑADIDO: Pulso más complejo (C1, G1, C2) para más movimiento rítmico
                            if (audioClock % (RHYTHM_STEP * 4) < RHYTHM_MULTIPLIER) {
                                basicPulseSynth.triggerAttackRelease('C1', '16n'); 
                            }
                            if (audioClock % (RHYTHM_STEP * 8) < RHYTHM_MULTIPLIER) {
                                basicPulseSynth.triggerAttackRelease('G1', '16n', Tone.now() + 0.05); // Ligeramente desfasado
                            }
                            if (audioClock % (RHYTHM_STEP * 16) < RHYTHM_MULTIPLIER) {
                                basicPulseSynth.triggerAttackRelease('C2', '16n', Tone.now() + 0.1); 
                            }
                            
                        } else if (planet.pulseType === 'percussive_bell') {
                            // PERCUSIVO (TAMBOR) - Ritmo Dinámico afectado por la gravedad (velocidad)
                            
                            const velocityRatio = 1.0 - distanceRatio; 
                            const minInterval = 0.2; 
                            const maxInterval = 2.0; 
                            const currentInterval = THREE.MathUtils.mapLinear(velocityRatio, 0, 1, maxInterval, minInterval);

                            if (currentTime - planet.lastPulseTime >= currentInterval * 1000) {
                                // Tono Tambor: Dinámico
                                const drumFrequency = THREE.MathUtils.mapLinear(distanceRatio, 0, 1, 300, 100); 
                                
                                drumSynth.triggerAttackRelease(drumFrequency, "8n");
                                
                                planet.lastPulseTime = currentTime;
                            }
                            
                        } else if (planet.pulseType === 'pulse_bass') {
                            // BAJO (SUB-BASS) - Ritmo Fijo y Lento
                            // Solo se dispara en el pulso más lento (1/4 o 1/2) para ser la base rítmica
                            if (audioClock % (RHYTHM_STEP * 8) < RHYTHM_MULTIPLIER) {
                                
                                // Tono Bajo: Dinámico
                                const bassFrequency = THREE.MathUtils.mapLinear(distanceRatio, 0, 1, 60, 20); // Notas muy graves 
                                
                                subBassSynth.triggerAttackRelease(bassFrequency, "4n");
                            }
                        } else if (planet.pulseType === 'glissando') {
                            // GLISSANDO (BARRIDO) - Pulso Rítmico con barrido de tono
                            if (audioClock % (RHYTHM_STEP * 8) < RHYTHM_MULTIPLIER) {
                                // Dispara una nota baja y la barre rápidamente a una nota alta
                                glissandoSynth.triggerAttack(Tone.Midi(36)); // C2 (grave)
                                glissandoSynth.frequency.linearRampToValueAtTime(Tone.Midi(48), Tone.now() + 0.3); // Barre a C3
                                glissandoSynth.triggerRelease(Tone.now() + 0.4); 
                            }
                        } else if (planet.pulseType === 'filtered_noise') {
                            // RUIDO FILTRADO (TEXTURA) - Ruido que se mueve con la distancia
                            if (audioClock % (RHYTHM_STEP * 4) < RHYTHM_MULTIPLIER) {
                                filteredNoiseSynth.triggerAttackRelease('16n');

                                // Modula la frecuencia de corte del filtro con la distancia
                                const filterFrequency = THREE.MathUtils.mapLinear(distanceRatio, 0, 1, 10000, 500); // 500Hz (Lejos) a 10000Hz (Cerca)
                                filteredNoiseSynth.filter.frequency.rampTo(filterFrequency, 0.1);
                            }
                        }
                    }


                    // d. Rotación propia del planeta
                    planet.mesh.rotation.y += 0.01;

                    // e. Actualizar rastro de órbita y colores (opacidad)
                    const orbitPositions = planet.orbitPositions;
                    const positionsAttribute = planet.trail.geometry.attributes.position;
                    const colorsAttribute = planet.trail.geometry.attributes.color;
                    const positionsForDrawing = positionsAttribute.array;
                    const colorsForDrawing = colorsAttribute.array;
                    
                    const index = planet.trailIndex * 3;

                    // 1. Guardar nueva posición
                    orbitPositions[index] = planet.mesh.position.x;
                    orbitPositions[index + 1] = planet.mesh.position.y;
                    orbitPositions[index + 2] = planet.mesh.position.z;

                    planet.trailIndex = (planet.trailIndex + 1) % planet.trailLength;
                    
                    if (planet.trailCount < planet.trailLength) {
                        planet.trailCount++;
                    }

                    // 2. Reordenar puntos y aplicar colores/opacidad
                    let p_index = 0; 
                    const totalPoints = planet.trailCount < planet.trailLength ? planet.trailCount : planet.trailLength;
                    const baseColor = planet.planetColor;

                    const updatePoint = (j, opacityRatio) => {
                        // Posición
                        positionsForDrawing[p_index * 3] = orbitPositions[j * 3];
                        positionsForDrawing[p_index * 3 + 1] = orbitPositions[j * 3 + 1];
                        positionsForDrawing[p_index * 3 + 2] = orbitPositions[j * 3 + 2];
                        
                        // Color y Opacidad (RGBA)
                        colorsForDrawing[p_index * 4] = baseColor.r;
                        colorsForDrawing[p_index * 4 + 1] = baseColor.g;
                        colorsForDrawing[p_index * 4 + 2] = baseColor.b;
                        colorsForDrawing[p_index * 4 + 3] = opacityRatio; // Opacidad

                        p_index++;
                    };
                    
                    const calculateOpacity = (i) => {
                        // i: índice absoluto del punto, de 0 al totalPoints-1
                        const minOpacity = 0.2;
                        const factor = 1.0 - minOpacity;
                        return minOpacity + (i / totalPoints) * factor; 
                    };


                    if (planet.trailCount < planet.trailLength) {
                        // FASE DE LLENADO: Rastro desde el punto 0 hasta el punto actual
                        for (let j = 0; j < planet.trailCount; j++) {
                            const opacityRatio = calculateOpacity(j);
                            updatePoint(j, opacityRatio);
                        }
                        planet.trail.geometry.setDrawRange(0, planet.trailCount);

                    } else {
                        // FASE ESTABLE: Rastro completo (buffer circular)
                        let opacityCounter = 0;
                        
                        // Parte A: Desde el punto actual (el más viejo) hasta el final del array
                        for (let j = planet.trailIndex; j < planet.trailLength; j++) {
                            const opacityRatio = calculateOpacity(opacityCounter++);
                            updatePoint(j, opacityRatio);
                        }
                        // Parte B: Desde el inicio del array (punto 0) hasta el punto actual (el más reciente)
                        for (let j = 0; j < planet.trailIndex; j++) {
                            const opacityRatio = calculateOpacity(opacityCounter++);
                            updatePoint(j, opacityRatio);
                        }
                        
                        planet.trail.geometry.setDrawRange(0, planet.trailLength);
                    }

                    positionsAttribute.needsUpdate = true;
                    colorsAttribute.needsUpdate = true; // Notificar a Three.js que los colores cambiaron
                }
            }
            
            // 2. Mover la Cámara (Controles Manuales e Inercia) - Esto siempre debe funcionar
            if (!isDragging) {
                theta += velocityX;
                phi -= velocityY; 
                velocityX *= DAMPING_FACTOR;
                velocityY *= DAMPING_FACTOR;
            }

            phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

            const x = ORBIT_RADIUS * Math.sin(phi) * Math.sin(theta);
            const y = ORBIT_RADIUS * Math.cos(phi);
            const z = ORBIT_RADIUS * Math.sin(phi) * Math.cos(theta);

            camera.position.set(x, y, z);
            camera.lookAt(0, 0, 0); 

            // 3. Renderizar la Escena
            renderer.render(scene, camera);
        }

        /**
         * Muestra un mensaje temporal en la pantalla (simula un alert, but with UI).
         */
        function showMessage(text, duration, color) {
            let messageBox = document.getElementById('messageBox');
            if (!messageBox) {
                messageBox = document.createElement('div');
                messageBox.id = 'messageBox';
                messageBox.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 p-3 rounded-lg shadow-xl text-white font-bold transition-opacity duration-300 pointer-events-none opacity-0 z-20';
                document.body.appendChild(messageBox);
            }
            
            messageBox.style.backgroundColor = color ? '#' + color.getHexString() : '#10b981';
            messageBox.textContent = text;
            messageBox.style.opacity = '1';
            
            clearTimeout(messageBox.timer);
            messageBox.timer = setTimeout(() => {
                messageBox.style.opacity = '0';
            }, duration);
        }

        // =================================================================
        // INICIO
        // =================================================================

        document.getElementById('startButton').addEventListener('click', () => {
            startAudioContext(); 
            
            const overlay = document.getElementById('overlay');
            overlay.style.opacity = '0';
            
            setTimeout(() => {
                overlay.style.pointerEvents = 'none';
            }, 500); 
            
            const controls = document.getElementById('controls');
            controls.style.opacity = '1';
            controls.style.pointerEvents = 'auto';

            init();
            animate();

            // CORRECCIÓN CRÍTICA: Enlazar los botones de control aquí,
            // después de que init() se ha llamado y los botones existen en el DOM
            document.getElementById('pauseButton').addEventListener('click', togglePause);
            document.getElementById('clearButton').addEventListener('click', clearSimulation);
            
            showMessage('¡Simulación Iniciada! Crea sistemas binarios y observa la gravedad.', 3500, new THREE.Color(0x22c55e));
        });

        // NOTA: EL EVENTO clearButton se ha movido dentro del listener de startButton
        // document.getElementById('clearButton').addEventListener('click', clearSimulation); 

    </script>
</body>
</html>


